# Assignment Two Feedback

## Group memebers: u6170245, u5553084, u5898869

## LATE SUBMISSION (SEE GIT LOG)
## Tutor Comment
Codes are well-commented, all files compiled and game.jar works
Very interesting game setup with different game modes and fancy interface:)
Clear instructions on user friendly interface
Cool animation for completion of the game
Good effort on generating solution dictionary
Appropriate use of OO features
Healthy use of git
Missing best statement for u5898869
WELL DONE!!!

## Mark

### Manual mark
| Task | Description | Mark |
|:-:|---|:-:|
|8|Basic game                       | 1/1 |
|9|Basic starting placements        | 1/1 |
|11|Hints                           | 1/1 |
|12|Interesting starting placements | 1/1 |

#### Manual mark 4/4


### Test results
| Task | Test | Result |
|:-:|---|:-:|
| |Compiled|1/1|
|3|PiecePlacementWellFormed|5/5|
|4|PlacementWellFormed|5/5|
|6|PegsForPiecePlacement|4/4|
|7|PlacementValid|5/5|
|10|Solutions|2/2|

#### Auto grade 7.0/7
### Deductions
| Description | Deduction |
|---|:-:|
|All files correct                | -.2/-1 |
|Authorship clear for all classes | /-1 |
|Appropriate use of git           | /-1 |
|Classes compile correctly        | /-1 |
|Program runs from jar            | /-1 |
|Appropriate use of OO features   | /-.5 |
|Presentation pdf complete        | /-.5 |
|Program well designed            | /-.5 |
|Comments clear and sufficient    | /-.5 |
|Coding style good                | /-.5 |
|Appropriate use of JUnit tests   | /-.5 |
|Design and code of very high quality | /-.5 |
|Works well and easy to run | /-.5 |

#### Total deductions: -.2

### Final mark 10.8/11
## Originality statement
e declare that the work we have submitted for Stage F of this assignment and all stages before it is entirely our own work, with the following documented exceptions:

* use google, oracle offical website and stackoverflow to learn some basic javafx and java.

* Jo-Lan Hu told us the idea of building a scoring system for this game.

Signed: Hongbo Zhang (u6170245), Shijie Qin (u5553084), Yifei Huang(u5898869)

## Git Log
```
commit dfa31768118bf8b510d99fae1a6288935c8f55f3
Merge: a807460 43faa56
Author: u6170245 <u6170245@anu.edu.au>
Date:   Sat Oct 15 20:11:24 2016 +1100

    Merge branch 'master' of https://gitlab.cecs.anu.edu.au/comp1110/comp1110-ass2

commit a80746035eca6663e5e1b3c11720778330077f71
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Fri Oct 14 07:50:13 2016 +1100

    Delete presetation.ppt

commit d60de1b0784eb352363a2b560a89ec0a338353a2
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Fri Oct 14 07:49:39 2016 +1100

    rename

commit 50a17426f5ecaac71f7a292fcd6041b72616c8f7
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Fri Oct 14 07:48:57 2016 +1100

    Delete presetation.pdf

commit 306f4f236a3d6e94dac05c1252f9af441b1de04e
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Fri Oct 14 07:48:07 2016 +1100

    rename

commit b558c50b8c1f393ffa6bdbda805418e73f245f43
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Fri Oct 14 07:38:50 2016 +1100

    presentation.ppt

commit 65919f5a65c8a051939ee6a50821ea021fe648f7
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Fri Oct 14 07:37:34 2016 +1100

    presentation.pdf

commit c11b58d3f32e2e0f0595768452653026393a4264
Author: u6170245 <u6170245@anu.edu.au>
Date:   Fri Oct 14 06:22:15 2016 +1100

    diff01.txt path issue, confused

commit d448021e798241fe0aebf65d20dfc1b4a6e90213
Author: u6170245 <u6170245@anu.edu.au>
Date:   Fri Oct 14 06:01:00 2016 +1100

    uml

commit fc0b7fd92426c64ed33abac8333f1dc089de715d
Author: u6170245 <u6170245@anu.edu.au>
Date:   Fri Oct 14 05:34:07 2016 +1100

    update G-features.md

commit 90f17f6934b82afb18ef6d7eb905ce209ef20e6c
Author: u6170245 <u6170245@anu.edu.au>
Date:   Fri Oct 14 04:58:05 2016 +1100

    restore record.txt

commit 2fbbd3fb5b402d0cc5be275436416e4c97d5b01b
Author: u6170245 <u6170245@anu.edu.au>
Date:   Fri Oct 14 04:55:59 2016 +1100

    originality, contribution, features and best

commit e0a695de77354790de9df1cf51c1c79d5d507d8b
Author: u6170245 <u6170245@anu.edu.au>
Date:   Fri Oct 14 04:12:06 2016 +1100

    add comments. & refactor abandoned codes

commit 5fa3432c0acc77e34cc5c3764c0a6ba4e87db9e0
Author: u6170245 <u6170245@anu.edu.au>
Date:   Fri Oct 14 03:41:28 2016 +1100

    GUI finished. & help for new users

commit af6427532a1279698c79c4d4de4f4f615c1eb3e5
Merge: 006d14a 0f6453a
Author: u6170245 <u6170245@anu.edu.au>
Date:   Fri Oct 14 02:27:24 2016 +1100

    Merge remote-tracking branch 'origin/master'

commit 006d14a23fe01ada211fda8baa88d4a4bfa92162
Author: u6170245 <u6170245@anu.edu.au>
Date:   Fri Oct 14 02:27:02 2016 +1100

    GUI update part 1

commit 0f6453a774dd109d6aff890ee6d3b3e0ba2c1433
Author: u5553084 <u5553084@anu.edu.au>
Date:   Fri Oct 14 02:10:15 2016 +1100

    G-best

commit 7fddd1b112b6b0e85548e48e2309ea61b434f2ec
Author: u5553084 <u5553084@anu.edu.au>
Date:   Fri Oct 14 00:30:32 2016 +1100

    Animation

commit fb11e60b4467a327eae904c3f9ed975e1ff340b1
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Oct 13 23:55:54 2016 +1100

    adventure mode: levelText

commit 14b311dccf534e4396a687b0625b1df4ffe87923
Merge: 2bbfe43 712d77a
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Oct 13 23:32:51 2016 +1100

    Merge branch 'master' of http://gitlab.cecs.anu.edu.au/u6170245/comp1110-ass2-thu11l

commit 2bbfe43b74d957a27b522cf0c255098bac6a8703
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Oct 13 23:32:36 2016 +1100

    new extensions: score system + completing animation + adventure mode

commit 712d77a9376c003ccfbdb1f4a470770b70f5046a
Author: Shijie  Qin <u5553084@anu.edu.au>
Date:   Thu Oct 13 20:41:15 2016 +1100

    PPT

commit 236bc841c2d5b6785fe07cd19ff0e58540cc8a09
Author: u5553084 <u5553084@anu.edu.au>
Date:   Thu Oct 13 19:45:26 2016 +1100

    diff

commit 2b9f9e4860c049bd84580e2f7815d24e53cc2e07
Merge: 1951854 9644658
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Oct 13 16:28:19 2016 +1100

    Merge remote-tracking branch 'origin/master'

commit 1951854ebcad0d1dd7ed962aef7c6a60dc8c8bab
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Oct 13 16:24:29 2016 +1100

    before group meeting

commit 9644658adbddc0fdb41e92dd7b049a154ffdc914
Author: Shijie  Qin <u5553084@anu.edu.au>
Date:   Thu Oct 13 16:17:05 2016 +1100

    Sols

commit 9f72d940f42b1a2e8facd8f8a0fe8431bb55c52b
Author: Shijie  Qin <u5553084@anu.edu.au>
Date:   Thu Oct 13 14:04:39 2016 +1100

    Sols

commit a5846d5d04fbeec470c473bcb7487d6a8b0ac871
Author: Shijie  Qin <u5553084@anu.edu.au>
Date:   Thu Oct 13 14:04:10 2016 +1100

    Delete TAD_Sols_2.txt

commit d75ce78e9daac1b05483725682568af0122af710
Author: Shijie  Qin <u5553084@anu.edu.au>
Date:   Thu Oct 13 14:02:32 2016 +1100

    Sols

commit 31dd2c6bc91e770256d7f28e40daca436f5413fd
Author: Shijie  Qin <u5553084@anu.edu.au>
Date:   Thu Oct 13 14:01:42 2016 +1100

    Sols

commit 8451db7846b6b3a9697469b9e03c1c16f3284e45
Author: Shijie  Qin <u5553084@anu.edu.au>
Date:   Thu Oct 13 14:01:12 2016 +1100

    Sols

commit 1cb30b5b19d07b3384b7ba03f84a17eab82551a8
Author: Shijie  Qin <u5553084@anu.edu.au>
Date:   Thu Oct 13 14:00:22 2016 +1100

    Delete BAA.txt

commit 5438945507b6f53aceb4f29f38e6ce0e737d2f5c
Author: Shijie  Qin <u5553084@anu.edu.au>
Date:   Thu Oct 13 13:58:13 2016 +1100

    Sols

commit 13f208c2c944fc4ad3165dccc6a01ceeb573ac82
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Oct 13 08:46:54 2016 +1100

    add timer to the board. & debug drag by right mouse button

commit e552d9876917f681b7b273fb70d456567f7a1086
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Oct 13 08:46:12 2016 +1100

    add timer to the board. & debug drag by right mouse button

commit 69e4da30cd1e826a680f284aa58b0fd4b844fbac
Merge: e694b5c 636031d
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Oct 13 06:23:27 2016 +1100

    Merge remote-tracking branch 'origin/master'
    
    Conflicts:
    	src/comp1110/ass2/SolutionDictionary/Solution.java

commit e694b5c61c98929c738f0d5eccb9ba873bd9de66
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Oct 13 06:20:57 2016 +1100

    Task12 stage1 & fix bugs in Draggale and LinkGame

commit 636031dafef09be6baf760a529a1bb3c4e01c3b3
Author: u5898869 <u5898869@uds.anu.edu.au>
Date:   Wed Oct 12 16:25:44 2016 +1100

    491 solutions

commit 8e05b91a14afc8f711ae26bbe32d6710cc35d3c0
Author: u5898869 <u5898869@uds.anu.edu.au>
Date:   Tue Oct 11 17:53:45 2016 +1100

    update to 197780 solutions

commit 56a15e701d00b395e2c2c0564e12db672e69e971
Author: u5898869 <u5898869@uds.anu.edu.au>
Date:   Tue Oct 11 17:52:59 2016 +1100

    solutions

commit 3db2f46fceb377df13e6fa2d6fe1974a366cf0b2
Author: u6170245 <u6170245@anu.edu.au>
Date:   Tue Oct 11 01:31:28 2016 +1100

    optimize validorigin by a new method validOriginForThisPiece, which takes account the specific piece

commit 6841b6a6c3def133ddf05f5109f4cccb718de364
Merge: 8ac704f 2e6353b
Author: u6170245 <u6170245@anu.edu.au>
Date:   Mon Oct 10 23:21:43 2016 +1100

    Merge branch 'master' of http://gitlab.cecs.anu.edu.au/u6170245/comp1110-ass2-thu11l

commit 2e6353b54a3f35b82631648f456634ede5f68a6a
Author: u5553084 <u5553084@anu.edu.au>
Date:   Mon Oct 10 17:51:55 2016 +1100

    linkegame update

commit 8739072bd6048d0bf121a852fef5db4b085cf6ee
Author: u5553084 <u5553084@anu.edu.au>
Date:   Mon Oct 10 17:47:54 2016 +1100

    solution update

commit 8ac704f7047d7df9585b5b325a158d67fcb63f41
Merge: 195438c 9c3859c
Author: u6170245 <u6170245@anu.edu.au>
Date:   Sat Oct 8 22:24:44 2016 +1100

    older version

commit 195438c6d8e6db6a9ee89b7179826c839745ddae
Author: u6170245 <u6170245@anu.edu.au>
Date:   Sat Oct 8 22:01:23 2016 +1100

    older version

commit 43faa56d8d61fb5efe5751c20c5cc1177a11f6ad
Author: COMP1110 Sem 2 2016 <steve.blackburn+comp1110-2016@anu.edu.au>
Date:   Thu Oct 6 21:42:02 2016 +1100

    Added two more simple good placements (that demonstrate a ring with a double opening).

commit 9c3859cdd34a241e93a387921449073767275f5a
Author: u5553084 <u5553084@anu.edu.au>
Date:   Thu Oct 6 18:03:30 2016 +1100

    update

commit ab57235a5252721f9a877ad3d974a106cb61b8bb
Author: u5553084 <u5553084@anu.edu.au>
Date:   Thu Oct 6 16:35:10 2016 +1100

    update

commit bd9e676c8c7896b074ec0c3f787e9efeaef32825
Author: u5553084 <u5553084@anu.edu.au>
Date:   Thu Oct 6 11:53:13 2016 +1100

    update

commit 2b9125216e48809ba6627061f3a8f7e3f2a8fad1
Author: u5553084 <u5553084@anu.edu.au>
Date:   Thu Oct 6 03:02:32 2016 +1100

    Update

commit b4c0706b0f2f0805619fd4cd03717baa31af2f95
Author: u5553084 <u5553084@anu.edu.au>
Date:   Thu Oct 6 02:53:37 2016 +1100

    Update

commit 17c70fa84ee841f61eaa4807e11d74a1b15fc8de
Author: u5553084 <u5553084@anu.edu.au>
Date:   Thu Oct 6 02:32:59 2016 +1100

    Update

commit 935f818d6d0b7f52888223ac805b08ebe06e0e70
Author: u5553084 <u5553084@anu.edu.au>
Date:   Wed Oct 5 21:27:57 2016 +1100

    Update

commit 954e18953790e8d33788dfa61723cbb345c6ef53
Author: u5553084 <u5553084@anu.edu.au>
Date:   Wed Oct 5 21:23:52 2016 +1100

    Update

commit 99aa69637f0c48859f8b7c85e02c0cfef0058dd9
Author: COMP1110 Sem 2 2016 <steve.blackburn+comp1110-2016@anu.edu.au>
Date:   Wed Oct 5 15:16:17 2016 +1100

    Added another simple bad placement

commit 172deccad79787a6d9566083a4cf8c727f35d369
Author: u5553084 <u5553084@anu.edu.au>
Date:   Tue Oct 4 19:17:36 2016 +1100

    demo

commit e04e50217a0c07819bf79a73fef4906a3917638a
Author: u6170245 <u6170245@anu.edu.au>
Date:   Mon Oct 3 19:41:07 2016 +1100

    all possible combination of four pieces. Used for generating starting placement of four pieces

commit a5648fc8ecb04dd5593f16240b7bc6de8f60efd1
Author: u6170245 <u6170245@anu.edu.au>
Date:   Mon Oct 3 17:54:14 2016 +1100

    make dictionary

commit 25faf3db985caeaa355d1d4795c320f6dfffd607
Author: u6170245 <u6170245@anu.edu.au>
Date:   Sun Oct 2 14:40:22 2016 +1100

    optimize the algorithm: alternative to deepCopy

commit ce7b08a2d9b63596d8b0c445332541ea6c17a3cd
Author: u6170245 <u6170245@anu.edu.au>
Date:   Sun Oct 2 03:53:07 2016 +1100

    optimize the algorithm of getSolutions and isPlacementValid

commit af29f06c639725bbc8ead3b9d7f61e0e1898fb5c
Author: u6170245 <u6170245@anu.edu.au>
Date:   Sun Oct 2 03:49:34 2016 +1100

    optimize the algorithm of getSolutions and isPlacementValid

commit 25f9bb63b89953c2e5e78605c4db28e343bc5096
Author: u5553084 <u5553084@anu.edu.au>
Date:   Thu Sep 29 17:13:30 2016 +1000

    update getSolutions

commit 00fb600b87b9a258847ad2991124d7968ae9afc2
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Wed Sep 28 23:19:35 2016 +1000

    Update F-originality.md

commit 2dd782f4497c08f91905fc5a5bca91b202dadf3b
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Wed Sep 28 23:17:50 2016 +1000

    contribution statement at Stage-F

commit 0cdfe4bf059511be44070f32b04542b95ba52c14
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Wed Sep 28 23:12:00 2016 +1000

    demo: game.jar

commit a2039e4f9b02e8ad45b4dcc86f0322ee105a5a4d
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Wed Sep 28 22:43:09 2016 +1000

    add comments

commit 45385f86d7e3aac3c0d4a6369bbafcb02bb8a811
Author: COMP1110 Sem 2 2016 <steve.blackburn+comp1110-2016@anu.edu.au>
Date:   Tue Sep 27 06:24:20 2016 +1000

    Increased timeouts by a further factor of 10x (excepting SolutionsTest).   They now all have 100x of slack, except for SolutionsTest, which has 10x.

commit 80290df42f9e77c07449eadcf680a994fb2d5c06
Author: u6170245 <u6170245@anu.edu.au>
Date:   Mon Sep 26 15:43:06 2016 +1000

    show "Congratulation" after successfully complete the game

commit d0c7b4602ac35a2e55b05ce8c64d7b43def4c1bf
Author: COMP1110 Sem 2 2016 <steve.blackburn+comp1110-2016@anu.edu.au>
Date:   Mon Sep 26 09:23:27 2016 +1000

    Added timeouts to tests

commit b14dbd9f0e60fca132c4a2a9df7526001fad0238
Author: u6170245 <u6170245@anu.edu.au>
Date:   Mon Sep 26 05:05:54 2016 +1000

    finish GUI v1.

commit 2053553c6631bd693635461cdd7e53be90c30f91
Author: u6170245 <u6170245@anu.edu.au>
Date:   Mon Sep 26 03:33:27 2016 +1000

    Finish Task 11: implement hints

commit c534dbb5ec43551b731e5195882dd8373f556a5f
Author: u5553084 <u5553084@anu.edu.au>
Date:   Sun Sep 25 15:31:28 2016 +1000

    task 10 update

commit 0faae93cda843b51a2b6ca2eab24231f9ba88c49
Author: u6170245 <u6170245@anu.edu.au>
Date:   Sun Sep 25 15:09:53 2016 +1000

    debug flip of Ball2 and Ring2

commit 9f605e2ce028e9ccf8191c8d610fa2b1045402fa
Merge: a359bc6 8aa9903
Author: u6170245 <u6170245@anu.edu.au>
Date:   Sun Sep 25 15:08:44 2016 +1000

    Merge remote-tracking branch 'origin/master'

commit a359bc6eaf234cb6fe715bb5dbbf24075063b32e
Author: u6170245 <u6170245@anu.edu.au>
Date:   Sun Sep 25 15:08:29 2016 +1000

    debug flip of Ring2 and Ball2

commit 8aa990384c49aad49c264c5a8549eda291d2846b
Author: u5553084 <u5553084@anu.edu.au>
Date:   Sun Sep 25 14:49:42 2016 +1000

    task 10 update

commit dd7adad0840a60a49eea46d0358bf5b360945fdb
Author: u5553084 <u5553084@anu.edu.au>
Date:   Sun Sep 25 11:52:11 2016 +1000

    task 10 update

commit 948919ad0cd40abd1fda980721d441418da9a3f1
Author: u5553084 <u5553084@anu.edu.au>
Date:   Sun Sep 25 11:29:31 2016 +1000

    task 10 update

commit 505db7ae85e3f4809bcd02b5a7944cb0d90bb8bc
Author: u6170245 <u6170245@anu.edu.au>
Date:   Sun Sep 25 02:47:16 2016 +1000

    fix bugs in Task 7. Pass the test of Task 7. And pass some other tests of Ring2 + Ball1

commit 902edd488cd05ce460160dfec90a9bff8fd60110
Author: u6170245 <u6170245@anu.edu.au>
Date:   Sun Sep 25 02:13:28 2016 +1000

    move HYF's test to tests folder

commit 28925330179fa2da9fce0d4da4ce1f2517fb76b6
Author: u6170245 <u6170245@anu.edu.au>
Date:   Sun Sep 25 02:12:01 2016 +1000

    debug isPlacementValid: allow Ring2 matches with Ball1

commit 0361a1a731b38195188f47d7dc56b0ef61e32179
Author: u6170245 <u6170245@anu.edu.au>
Date:   Sun Sep 25 00:45:16 2016 +1000

    debug getPegForPiecePlacement()

commit d246b5e88696b8dcf66c443fb566044944cee7c1
Author: u6170245 <u6170245@anu.edu.au>
Date:   Sat Sep 24 23:47:18 2016 +1000

    Finish Task 8. "Ensure that you can check whether the piece placement is valid. If the placement is not valid, don't allow the player to place the piece."

commit 92c7501e69af80a4a6133ff859f0bbfc487f863c
Merge: cbffa75 edd1a32
Author: u6170245 <u6170245@anu.edu.au>
Date:   Sat Sep 24 21:54:28 2016 +1000

    Merge remote-tracking branch 'origin/master'

commit cbffa75cb77d64fba45f435aa7b9b110cc6e0d7f
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Sat Sep 24 21:54:06 2016 +1000

    debug isPlacementValid

commit edd1a3212d5295e73fe252e0ee55fb37536aeb13
Author: Shijie  Qin <u5553084@anu.edu.au>
Date:   Thu Sep 22 12:16:03 2016 +1000

    Delete FixTest.java

commit bff98907b5db9f815438186e3e9b08ca1facd26d
Author: u5553084 <u5553084@anu.edu.au>
Date:   Thu Sep 22 12:15:21 2016 +1000

    FixTest

commit 9de04600b26f00edfb619bee62505dd91d53c8b9
Author: Shijie  Qin <u5553084@anu.edu.au>
Date:   Thu Sep 22 12:09:28 2016 +1000

    FixTest

commit 63e7d201e1d28408134c1cb5c42157cab8667e91
Author: Shijie  Qin <u5553084@anu.edu.au>
Date:   Thu Sep 22 12:05:27 2016 +1000

    originality

commit 5e5c2fb589566d35fdc9d2b22b4ea02cf8f46a03
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Thu Sep 22 11:46:28 2016 +1000

    E-originality-u6170245.md in Week 8

commit f5bdc8f98070976234ea20e172e3dca7cb5f6aae
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Thu Sep 22 11:43:31 2016 +1000

    Update E-originality-u6170245.md in Week 8

commit d24f73f8e017d03f213f612a1b2f53c8799660e9
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Sep 22 04:58:15 2016 +1000

    not used any longer. Keep a copy here for use in the future if possible

commit efdf181e4371f6ab5233558a820d6359cbda715f
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Sep 22 04:52:19 2016 +1000

    Add new test

commit dcaea21676ff6f6880eece2bbf890778aaf5f063
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Sep 22 04:51:50 2016 +1000

    Fix bug. Add restorePiece() method. Otherwise, the enum Piece will not be restored after translateOrientation()

commit 4451d1a8abbc486feafdcfa4855364ddcbec2ab4
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Sep 22 04:50:43 2016 +1000

    Finish Task 7.

commit 9e7919fa55371f0e09d72d52e38b6c00814c1b10
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Sep 22 04:02:11 2016 +1000

    test translationOrientation method

commit c3ec875e14fd11c823daa6f0cf27bf52e4cfd58e
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Sep 22 04:01:23 2016 +1000

    add toString method for debug

commit b8abaf0f4a3fc4f55804ff2896555e8a4c01af17
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Sep 22 04:00:54 2016 +1000

    modify the tranlateorientation method: consider the case of flipping, rings without opening, invalid piece and invalid piece orientation.

commit f7a2c3918e3c14562a2648f2778b1a010354f56d
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Sep 22 03:59:06 2016 +1000

    Update the convention of orientation of units in Piece

commit 9ee203d28886ace9e157ee7a719ea7d213eecc68
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Thu Sep 22 03:58:04 2016 +1000

    Write codes relevant to Task 7.

commit a818bb785931ce4d9fd5989294acc03b7896cb68
Author: u5898869 <u5898869@uds.anu.edu.au>
Date:   Wed Sep 21 16:06:52 2016 +1000

    test

commit 49921f8b46bd4309733b97e102819524bb5aab33
Author: u5553084 <u5553084@anu.edu.au>
Date:   Tue Sep 20 18:21:35 2016 +1000

    update

commit 39c291259ec4533d0b414fbc3bb863ea95387994
Author: u5553084 <u5553084@anu.edu.au>
Date:   Tue Sep 20 17:58:53 2016 +1000

    FixTest

commit c3542a5ae8d5786013954c4a8b9bba93f4618707
Author: COMP1110 Sem 2 2016 <steve.blackburn+comp1110-2016@anu.edu.au>
Date:   Thu Sep 15 13:46:08 2016 +1000

    Removed test case with three starting pieces (the assignment only asks you to solve for four or more starting pieces)

commit c14675f6987529562f81bf88f35dd6b0c447d6db
Author: u5553084 <u5553084@anu.edu.au>
Date:   Wed Sep 14 21:01:52 2016 +1000

    Task7-Shijie

commit bf5df5da17591bf5192276e5e425ad045851bd0d
Author: u5553084 <u5553084@anu.edu.au>
Date:   Wed Sep 14 20:50:26 2016 +1000

    Task7-Shijie

commit 8946186cad614206838f887e00b8d001bff700a6
Author: u5553084 <u5553084@anu.edu.au>
Date:   Wed Sep 14 20:45:37 2016 +1000

    Task7-Shijie

commit ea517c7111705ffbb472cee9bc838239b72ebecf
Merge: 86b2640 0b9df03
Author: u5898869 <u5898869@uds.anu.edu.au>
Date:   Wed Sep 14 16:09:58 2016 +1000

    Merge remote-tracking branch 'origin/master'

commit c1eb0283e9da160c2f6dcca10056c70e6de7b5a4
Merge: fc179c1 7c23cfd
Author: COMP1110 Sem 2 2016 <steve.blackburn+comp1110-2016@anu.edu.au>
Date:   Wed Sep 14 16:07:16 2016 +1000

    Merge remote-tracking branch 'origin/master'

commit fc179c1d0a21005e67b3b38c340f4604bca231f7
Author: COMP1110 Sem 2 2016 <steve.blackburn+comp1110-2016@anu.edu.au>
Date:   Wed Sep 14 16:06:57 2016 +1000

    Fix bug in invalidPiecePlacement, thanks to group tue13h.

commit 86b26409a537be8adbbb67a6c981a89e82c826bd
Author: u5898869 <u5898869@uds.anu.edu.au>
Date:   Sun Sep 11 16:02:04 2016 +1000

    UNIT

commit 0b9df030ed983ae4bcd6215a4700918e4908cdda
Author: u5553084 <u5553084@anu.edu.au>
Date:   Wed Aug 31 23:36:27 2016 +1000

    Unit

commit 2383cc833b3363cd377ff2ced8f315bd7bca4518
Author: u5553084 <u5553084@anu.edu.au>
Date:   Wed Aug 31 23:36:12 2016 +1000

    Piece

commit f7555ebe80a55d7c973a34e4d81e1e152282bb2f
Author: u5553084 <u5553084@anu.edu.au>
Date:   Wed Aug 31 23:35:50 2016 +1000

    Orientation

commit 2855fe58d22e978336c52f5fe7c91bde957e2681
Author: u5553084 <u5553084@anu.edu.au>
Date:   Wed Aug 31 23:35:24 2016 +1000

    originality statement of Shijie Qin

commit adcb526ede665c714c1f72c02241535d690d4757
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Tue Aug 30 08:55:53 2016 +1000

    originality statement of Hongbo Zhang

commit bccfa563bae0acd5997a80238a133048003f2e8a
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Tue Aug 30 08:39:09 2016 +1000

    Add mouse events to the constructor of Draggable. And code several functions such as rotate(), flip(), snap(), snapToHome() and so on

commit 44d891cf0abf8e1dcb96eb770c7ef29f276d0e4f
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Thu Aug 25 09:28:08 2016 +1000

    Update C-originality.md after finishing Task 6

commit 76cc17e95eaf1cdeec00d4df7973c5d85b6b9e2c
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Thu Aug 25 09:27:36 2016 +1000

    Update C-contribution.md after completing Task 6

commit e0daa1c2054d9df1dc97094f6850db2009fedc75
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Thu Aug 25 09:23:45 2016 +1000

    Task 6. finished. pass all the four tests

commit 2a979b34f39b0df700447ee51c443c9d988caab7
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Thu Aug 25 07:53:45 2016 +1000

    Task 6. finished.
    Different "-1" definition with tester.

commit 7c78f237c9e9cd81d82eece0f8dfa2241c949762
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Thu Aug 25 03:23:50 2016 +1000

    Update C-contribution.md after finishing Task 3, 4, 5

commit dd912687a924b7af6ef67b4a5203206b4b396f0f
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Thu Aug 25 03:21:37 2016 +1000

    Update C-originality.md after finishing Task 3,4,5.

commit a014d2fa7864c9d6777eaa5d28d9c8f5157a03d8
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Thu Aug 25 03:04:56 2016 +1000

    Task 5 finished. Successful display the placement visually.
    Class Draggable and PegArray are also provided.
    Draggable hasn't been finished yet.
    Modified the access of method in LinkGame to be "public"

commit cc8806283f7bcfe12286693f4877df9358f86dfe
Merge: d640b0b ad1213f
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Aug 25 02:59:49 2016 +1000

    Merge remote-tracking branch 'origin/master'

commit d640b0b86d97dda1905016f1f518c553223d4ee2
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Thu Aug 25 02:59:14 2016 +1000

    Task 5 finished. Successful display the placement visually.
    Class Draggable and PegArray are also provided.
    Draggable hasn't been finished yet.
    Modified the access of method in LinkGame to be "public"

commit ad1213f9e9d6e4c5931c1decb23c43dc9fbcae5c
Author: u5898869 <u5898869@uds.anu.edu.au>
Date:   Mon Aug 22 15:39:19 2016 +1000

    task3

commit 24085dbe50f08c1b24c816ae6f6ae57904a6ead6
Merge: f5c89a9 70bc83a
Author: u6170245 <u6170245@anu.edu.au>
Date:   Mon Aug 22 03:46:30 2016 +1000

    Merge branches 'BobsExperiment' and 'master' of http://gitlab.cecs.anu.edu.au/u6170245/comp1110-ass2-thu11l

commit 70bc83a49966db29ea6940d216a683acfdd37092
Author: u5553084 <u5553084@anu.edu.au>
Date:   Fri Aug 19 14:39:32 2016 +1000

    Task 4 completed

commit 7c23cfdafdbe4291e78f71de9d686684096bd63e
Author: COMP1110 Sem 2 2016 <steve.blackburn+comp1110-2016@anu.edu.au>
Date:   Thu Aug 18 23:53:50 2016 +1000

    Clarify peg numbering

commit 08445aff8d4d86999a13299e554d60e82f401c7e
Merge: b42d6ac f6282e2
Author: u5553084 <u5553084@anu.edu.au>
Date:   Thu Aug 18 12:29:41 2016 +1000

    Merge remote-tracking branch 'origin/master'
    
    # Conflicts:
    #	src/gittest/Main.java

commit b42d6ac79fbdc7067299205f2ef4aa888dc1eef7
Author: Bob <u1234567@anu.edu.au>
Date:   Thu Aug 18 12:28:58 2016 +1000

    new line B

commit f6282e2941247010390a123d233e0576c7d4e28f
Merge: 00058cd 14adb46
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Aug 18 12:28:44 2016 +1000

    Merge remote-tracking branch 'origin/master'
    
    # Conflicts:
    #	src/gittest/Main.java

commit 00058cdfb5a47b99bdda8cbb12d7ce2e2708d52b
Author: Alice <u6170245@anu.edu.au>
Date:   Thu Aug 18 12:28:11 2016 +1000

    try again

commit 14adb46df897de26487a389139b3dd4198cf840b
Author: Cindy <u5898869@anu.edu.au>
Date:   Thu Aug 18 12:27:05 2016 +1000

    made a further modification

commit 8190851f0727d74223f6c04ea05e2f103460e2e7
Merge: f99b250 3155284
Author: u5553084 <u5553084@anu.edu.au>
Date:   Thu Aug 18 12:24:08 2016 +1000

    Merge remote-tracking branch 'origin/master'
    
    # Conflicts:
    #	src/gittest/Main.java

commit f99b2507ab2953921d3e4332c5f9da42ca9237ce
Author: Bob <u1234567@anu.edu.au>
Date:   Thu Aug 18 12:23:20 2016 +1000

    new line B

commit 315528415b97860fdf821d9e837c64318604009d
Author: Alice <u6170245@anu.edu.au>
Date:   Thu Aug 18 12:22:39 2016 +1000

    redone

commit 4360cb7b850463c437fb97f6d40dd5afdb03aec2
Author: Yifan Huang <u5898869@uds.anu.edu.au>
Date:   Thu Aug 18 12:20:09 2016 +1000

    made a further modification

commit 907302d472ffb71861423494af69d6f5948451e2
Merge: 0372b03 2f1d671
Author: Yifan Huang <u5898869@uds.anu.edu.au>
Date:   Thu Aug 18 12:17:10 2016 +1000

    Merge remote-tracking branch 'origin/master'
    
    # Conflicts:
    #	src/gittest/Main.java

commit 2f1d6713afd64bfd6f80b51f03db4b7d3641923d
Merge: 313485f 598f6c1
Author: u5553084 <u5553084@anu.edu.au>
Date:   Thu Aug 18 12:15:58 2016 +1000

    Merge remote-tracking branch 'origin/master'
    
    # Conflicts:
    #	src/gittest/Main.java

commit 313485f2efcc921a32258a6a195d8024e1255a0f
Author: Bob <u1234567@anu.edu.au>
Date:   Thu Aug 18 12:14:03 2016 +1000

    new line B

commit 598f6c1327cfc2d50d2de0406cf67193481ce7c4
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Aug 18 12:13:08 2016 +1000

    add A in Main

commit 0372b03868d88a809fb5238f253554b27ef88694
Author: Yifan Huang <u5898869@uds.anu.edu.au>
Date:   Thu Aug 18 12:11:49 2016 +1000

    group ass

commit f5c89a9f5cfe55be355a8b9dfd19fb84cc33d925
Author: Bob <u1234567@anu.edu.au>
Date:   Thu Aug 18 12:03:58 2016 +1000

    This is class B

commit 139c014fe55dd9e8e8ca58c6accf0e3eff643c2d
Author: Bob <u1234567@anu.edu.au>
Date:   Thu Aug 18 12:03:23 2016 +1000

    This is class B

commit ce269ef821cc292b18df5dd48930e0c364a5fcdd
Merge: e148084 551a030
Author: u5553084 <u5553084@anu.edu.au>
Date:   Thu Aug 18 11:37:28 2016 +1000

    Merge remote-tracking branch 'origin/master'

commit 551a0300b17697afc63c33c2a79ed1b50bfefdc4
Author: Yifan Huang <u5898869@uds.anu.edu.au>
Date:   Thu Aug 18 11:36:55 2016 +1000

    group ass

commit 01f86cb305085256cff0d6226b7c1358079ba00e
Author: Yifan Huang <u5898869@uds.anu.edu.au>
Date:   Thu Aug 18 11:35:28 2016 +1000

    group ass

commit e148084643cf4b160297222fa8d38da7bd846c5c
Author: Bob <u1234567@anu.edu.au>
Date:   Thu Aug 18 11:32:38 2016 +1000

    This is class B

commit 67aa621e086585ad925a6e72a5b17d8c399f5da4
Merge: 1897820 c4f9a3c
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Aug 18 11:26:23 2016 +1000

    Merge branch 'master' of https://gitlab.cecs.anu.edu.au/comp1110/comp1110-ass2

commit 18978201b66176940928cc546c825178133fc1ad
Merge: b99246d 0738ac1
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Aug 18 11:26:01 2016 +1000

    Merge branch 'master' of https://gitlab.cecs.anu.edu.au/u6170245/comp1110-ass2-thu11l

commit b99246d5dc13509275d16a5648cd45b2ca19f8ed
Author: Alice <u6170245@anu.edu.au>
Date:   Thu Aug 11 12:32:39 2016 +1000

    information of our group

commit 0738ac14e00d86df32b59ab7da8c91ae1f9a1413
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Thu Aug 18 04:05:42 2016 +1000

    Update B-contribution.md aftering correcting some typo

commit 1ff10f694f747685fc4b8bb957645328c0a99ded
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Thu Aug 18 04:04:50 2016 +1000

    Update B-contribution.md after finishing Task 2

commit 3f32375fa68659d5679c60435c5061c583f608f7
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Thu Aug 18 03:57:07 2016 +1000

    Update B-originality.md for typesetting

commit 0df623ffc6beed937820d9738d60c1f6f586ca3f
Author: Hongbo  Zhang <u6170245@anu.edu.au>
Date:   Thu Aug 18 03:56:17 2016 +1000

    Update B-originality.md after finishing Task2

commit 5cc0b8e5c1b021a295ad01b3a82404d687aa5ce5
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Aug 18 03:43:25 2016 +1000

    The uml of comp1110-ass2 of thu11l. Hongbo uploaded this uml.png on the behalf of all the members in the group. All the group members discussed together, worked together and equally contributed to this uml.

commit 94897b99f922d6f67909db9e83b8e7f0260c7159
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Aug 18 03:35:06 2016 +1000

    The uml of comp1110-ass2 of thu11l. Hongbo uploaded this uml.png on the behalf of all the members in the group. All the group members discussed together, worked together and equally contributed to this uml.

commit c4f9a3ce49079e394ae448d7f5efe43d895bb3fb
Author: COMP1110 Sem 2 2016 <steve.blackburn+comp1110-2016@anu.edu.au>
Date:   Tue Aug 16 13:33:12 2016 +1000

    Make it clear how units are numbered.

commit b725d00d654b9cf06b26817e66c5b58e35b7bc24
Author: COMP1110 Sem 2 2016 <steve.blackburn+comp1110-2016@anu.edu.au>
Date:   Tue Aug 16 13:28:47 2016 +1000

    Typos: change 'link' to 'unit'

commit 73ae4739fc8f0a4804c3c8c1e45a46ea2e55e5ff
Author: COMP1110 Sem 2 2016 <steve.blackburn+comp1110-2016@anu.edu.au>
Date:   Tue Aug 16 06:35:23 2016 +1000

    Added missing test for duplicate pieces

commit 31f8dd7b82d7eeb361fc3e0019189dfbbf090e80
Author: COMP1110 Sem 2 2016 <steve.blackburn+comp1110-2016@anu.edu.au>
Date:   Mon Aug 15 23:06:26 2016 +1000

    Added tests

commit ce45890548e232253feb91620ab04e6a04e55d2a
Author: COMP1110 Sem 2 2016 <steve.blackburn+comp1110-2016@anu.edu.au>
Date:   Mon Aug 15 23:05:49 2016 +1000

    Clarify that the A piece has only six valid orientations

commit 995ba01ac70992a368965f387b4fff25ad1ba246
Author: COMP1110 Sem 2 2016 <steve.blackburn+comp1110-2016@anu.edu.au>
Date:   Mon Aug 15 23:04:48 2016 +1000

    Remove stray line

commit ef26a4dd9ccfbc41c0432ed3ee474e79f776c635
Author: u6170245 <u6170245@anu.edu.au>
Date:   Thu Aug 11 12:32:39 2016 +1000

    information of our group

commit 6de4754635d96596632efa382a422f4ed36a9e4c
Author: COMP1110 Sem 2 2016 <steve.blackburn+comp1110-2016@anu.edu.au>
Date:   Wed Aug 10 06:52:17 2016 +1000

    Update README.md

commit 08f7d62a026f4aa630d6ca9951361fd20c7a6397
Author: COMP1110 Sem 2 2016 <steve.blackburn+comp1110-2016@anu.edu.au>
Date:   Tue Aug 9 02:05:06 2016 +1000

    Initial import
```
## Changes
```
Only in comp1110-ass2/admin: A-information
diff -ru -x .git ../master/comp1110-ass2/admin/B-contribution.md comp1110-ass2/admin/B-contribution.md
--- ../master/comp1110-ass2/admin/B-contribution.md	2016-10-16 20:56:26.278208910 +0800
+++ comp1110-ass2/admin/B-contribution.md	2016-10-16 20:58:44.198692016 +0800
@@ -1,7 +1,9 @@
 We declare that the work toward our submission of Stage B was distributed among the group members as follows:
 
-* u2345678 30
-* u3456789 40
-* u0234567 30
+All the group members equally contributed to this uml.
 
-Signed: Mary Jones (u2345678), Bob Smith (u3456789), and Sue Black (u0234567)
+We discussed together, worked together. And every member in the group handed in a draft uml of this project.
+
+Finally, Hongbo Zhang made some edition and pushed it to Github.
+
+Signed: Hongbo Zhang (u6170245), Shijie Qin (u5553084), Yifei Huang(u5898869)
diff -ru -x .git ../master/comp1110-ass2/admin/B-originality.md comp1110-ass2/admin/B-originality.md
--- ../master/comp1110-ass2/admin/B-originality.md	2016-10-16 20:56:26.278208910 +0800
+++ comp1110-ass2/admin/B-originality.md	2016-10-16 20:58:44.198692016 +0800
@@ -1,9 +1,11 @@
 We declare that the work we have submitted for Stage B of this assignment and all stages before it is entirely our own work, with the following documented exceptions:
 
-* The idea of using <...> to make the game run faster came from a discussion with <...> (noted in source code comments)
+All the program design and uml plotting are done by our group independently, without discussion with any other group, or copy the design from any other group.
 
-* The code in class <...> is based on a solution we found when researching the problem (URL provided in source code comments)
+Except:
 
-*  ....
+1 we refer to the GUI part of assignment 1 for learning JAVAFX and design our own GUI.
 
-Signed: Mary Jones (u2345678), Bob Smith (u3456789), and Sue Black (u0123456)
+2 we use Google to learn the usage of "umbrello" and some basic knowledge/convention of uml.
+
+Signed: Hongbo Zhang (u6170245), Shijie Qin (u5553084), Yifei Huang(u5898869)
diff -ru -x .git ../master/comp1110-ass2/admin/C-contribution.md comp1110-ass2/admin/C-contribution.md
--- ../master/comp1110-ass2/admin/C-contribution.md	2016-10-16 20:56:26.278208910 +0800
+++ comp1110-ass2/admin/C-contribution.md	2016-10-16 20:58:44.198692016 +0800
@@ -1,7 +1,7 @@
-We declare that the work toward our submission of Stage C was distributed among the group members as follows:
+We declare that the work toward our submission of Stage C (Task 3, 4, 5 and 6) was distributed among the group members as follows:
 
-* u2345678 30
-* u3456789 40
-* u0234567 30
+* Hongbo Zhang (u6170245) 40
+* Shijie Qin (u5553084)   30
+* Yifei Huang(u5898869)   30
 
-Signed: Mary Jones (u2345678), Bob Smith (u3456789), and Sue Black (u0234567)
+Signed: Hongbo Zhang (u6170245), Shijie Qin (u5553084), Yifei Huang(u5898869)
diff -ru -x .git ../master/comp1110-ass2/admin/C-originality.md comp1110-ass2/admin/C-originality.md
--- ../master/comp1110-ass2/admin/C-originality.md	2016-10-16 20:56:26.278208910 +0800
+++ comp1110-ass2/admin/C-originality.md	2016-10-16 20:58:44.198692016 +0800
@@ -1,9 +1,15 @@
-We declare that the work we have submitted for Stage C of this assignment and all stages before it is entirely our own work, with the following documented exceptions:
+We declare that the work we have submitted for Stage C of this assignment (Task 3, 4, 5 and 6) and all stages before it is entirely our own work, with the following documented exceptions:
 
-* The idea of using <...> to make the game run faster came from a discussion with <...> (noted in source code comments)
+All the program coding and design are done independently by our group, without any discussion with any other group, or copying the source code from any other source.
 
-* The code in class <...> is based on a solution we found when researching the problem (URL provided in source code comments)
+Except:
 
-*  ....
+1 We use java documentation on Oracle offical website to learn javafx and some knowlege of java, such as lambda expression, anonymous class, exception handling and so on.
 
-Signed: Mary Jones (u2345678), Bob Smith (u3456789), and Sue Black (u0123456)
+https://docs.oracle.com/javase/8
+
+https://docs.oracle.com/javase/tutorial
+
+2 We refer to the GUI part of Board class in ass1 to learn javafx.
+
+Signed: Hongbo Zhang (u6170245), Shijie Qin (u5553084), Yifei Huang(u5898869)
Only in comp1110-ass2/admin: D-originality-u5553084.md
Only in comp1110-ass2/admin: D-originality-u6170245.md
diff -ru -x .git ../master/comp1110-ass2/admin/E-originality-u1234567.md comp1110-ass2/admin/E-originality-u1234567.md
--- ../master/comp1110-ass2/admin/E-originality-u1234567.md	2016-10-16 20:56:26.278208910 +0800
+++ comp1110-ass2/admin/E-originality-u1234567.md	2016-10-16 20:58:44.198692016 +0800
@@ -1,8 +1,3 @@
-I declare that the work I have submitted for Stage E of this assignment and all stages before it is entirely my own work, with the
-following documented exceptions:
+I declare that the work I have submitted for Stage E of this assignment, including Task 7, other relevant codes related to Task 7 and the test, and all stages before it is entirely my own work, 
 
-* The idea of <...> came from a discussion with <...>
-
-* The code in class <...> uses an idea suggested by <...>
-
-Signed: Mary Jones (u23445678)
+Signed: Hongbo Zhang (u6170245)
Only in comp1110-ass2/admin: E-originality-u5553084.md
Only in comp1110-ass2/admin: E-originality-u6170245.md
diff -ru -x .git ../master/comp1110-ass2/admin/F-contribution.md comp1110-ass2/admin/F-contribution.md
--- ../master/comp1110-ass2/admin/F-contribution.md	2016-10-16 20:56:26.278208910 +0800
+++ comp1110-ass2/admin/F-contribution.md	2016-10-16 20:58:44.198692016 +0800
@@ -1,8 +1,7 @@
-We declare that the work toward our submission of Stage F was distributed among the group members as follows:
+We declare that the work toward our submission of Stage F (finish all the things expect Task 12, new extension and upgrade the algorithm of Task 7 and Task 10) was distributed among the group members as follows:
 
-* u2345678 30
-* u3456789 40
-* u0123456 30
-
-Signed: Mary Jones (u2345678), Bob Smith (u3456789), and Sue Black (u0123456)
+* Hongbo Zhang (u6170245) 35
+* Shijie Qin (u5553084)   35
+* Yifei Huang(u5898869)   30
 
+Signed: Hongbo Zhang (u6170245), Shijie Qin (u5553084), Yifei Huang(u5898869)
diff -ru -x .git ../master/comp1110-ass2/admin/F-originality.md comp1110-ass2/admin/F-originality.md
--- ../master/comp1110-ass2/admin/F-originality.md	2016-10-16 20:56:26.278208910 +0800
+++ comp1110-ass2/admin/F-originality.md	2016-10-16 20:58:44.198692016 +0800
@@ -1,9 +1,5 @@
 We declare that the work we have submitted for Stage F of this assignment and all stages before it is entirely our own work, with the following documented exceptions:
 
-* The idea of using <...> to make the game run faster came from a discussion with <...> (noted in source code comments)
+* use google, oracle offical website and stackoverflow to learn some basic javafx and java.
 
-* The code in class <...> is based on a solution we found when researching the problem (URL provided in source code comments)
-
-* ....
-
-Signed: Mary Jones (u2345678), Bob Smith (u3456789), and Sue Black (u0123456)
+Signed: Hongbo Zhang (u6170245), Shijie Qin (u5553084), Yifei Huang(u5898869)
\ No newline at end of file
Only in comp1110-ass2/admin: G-best-u5553084.md
Only in comp1110-ass2/admin: G-best-u6170245.md
diff -ru -x .git ../master/comp1110-ass2/admin/G-contribution.md comp1110-ass2/admin/G-contribution.md
--- ../master/comp1110-ass2/admin/G-contribution.md	2016-10-16 20:56:26.278208910 +0800
+++ comp1110-ass2/admin/G-contribution.md	2016-10-16 20:58:44.198692016 +0800
@@ -1,8 +1,10 @@
-We declare that the work toward our submission of Stage G was distributed among the group members as follows:
+We declare that the work toward our submission of Stage G 
+(finish all the things including Task 12, new extension and upgrade the algorithm of Task 7 and Task 10),
+ was distributed among the group members as follows:
 
-* u2345678 30
-* u3456789 40
-* u0123456 30
+* Hongbo Zhang (u6170245) 3/8
+* Shijie Qin (u5553084)   3/8
+* Yifei Huang(u5898869)   2/8
 
-Signed: Mary Jones (u2345678), Bob Smith (u3456789), and Sue Black (u0123456)
+Signed: Hongbo Zhang (u6170245), Shijie Qin (u5553084), Yifan Huang(u5898869)
 
diff -ru -x .git ../master/comp1110-ass2/admin/G-features.md comp1110-ass2/admin/G-features.md
--- ../master/comp1110-ass2/admin/G-features.md	2016-10-16 20:56:26.278208910 +0800
+++ comp1110-ass2/admin/G-features.md	2016-10-16 20:58:44.198692016 +0800
@@ -3,13 +3,19 @@
 
 *(Remove those that are unimplemented)*
 
- - A simple placement viewer (Task 5)
- - A basic playable link game
- - A basic playable link game that snaps pieces to pegs and checks for validity (Task 8)
- - A basic implementation  of starting piece placements (Task 9)
- - Solution hints
- - Interesting starting placements, generated by our code.
+ * A simple placement viewer (Task 5)
+ * A basic playable link game
+ * A basic playable link game that snaps pieces to pegs and checks for validity (Task 8)
+ * A basic implementation  of starting piece placements (Task 9)
+ * Solution hints
+ * Interesting starting placements, generated by our code.
 
 additional features...
 
+ * score system of this game. (recommended by our tutor Jo-Lan Hu)
+ * two game modes: training mode and adventure mode.
+ * a fancy animation when completing the game successfully.
+ * a timer to record the how long the game lasts, or count down.
+ * a friendly and detailed help in GUI.
+
 
diff -ru -x .git ../master/comp1110-ass2/admin/G-originality.md comp1110-ass2/admin/G-originality.md
--- ../master/comp1110-ass2/admin/G-originality.md	2016-10-16 20:56:26.278208910 +0800
+++ comp1110-ass2/admin/G-originality.md	2016-10-16 20:58:44.198692016 +0800
@@ -1,9 +1,7 @@
-We declare that the work we have submitted for Stage G of this assignment and all stages before it is entirely our own work, with the following documented exceptions:
+e declare that the work we have submitted for Stage F of this assignment and all stages before it is entirely our own work, with the following documented exceptions:
 
-* The idea of using <...> to make the game run faster came from a discussion with <...> (noted in source code comments)
+* use google, oracle offical website and stackoverflow to learn some basic javafx and java.
 
-* The code in class <...> is based on a solution we found when researching the problem (URL provided in source code comments)
+* Jo-Lan Hu told us the idea of building a scoring system for this game.
 
-* ....
-
-Signed: Mary Jones (u2345678), Bob Smith (u3456789), and Sue Black (u0123456)
+Signed: Hongbo Zhang (u6170245), Shijie Qin (u5553084), Yifei Huang(u5898869)
Only in comp1110-ass2: ANUPowerpointTemplate2010-3.ppt
Only in comp1110-ass2: ass2_overall.uml
Only in comp1110-ass2: bkup
Only in comp1110-ass2: feedback.md
Only in comp1110-ass2: game.jar
Only in comp1110-ass2: gui.png
Only in comp1110-ass2: gui.uml
Only in comp1110-ass2/.idea: artifacts
diff -ru -x .git ../master/comp1110-ass2/.idea/comp1110-ass2-dev.iml comp1110-ass2/.idea/comp1110-ass2-dev.iml
--- ../master/comp1110-ass2/.idea/comp1110-ass2-dev.iml	2016-10-16 20:56:26.278208910 +0800
+++ comp1110-ass2/.idea/comp1110-ass2-dev.iml	2016-10-16 20:58:44.186691441 +0800
@@ -6,8 +6,20 @@
       <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
       <sourceFolder url="file://$MODULE_DIR$/src-dev" isTestSource="false" />
       <sourceFolder url="file://$MODULE_DIR$/tests" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/comp1110/ass2/Test" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/comp1110/ass2/tests" isTestSource="true" />
     </content>
     <orderEntry type="inheritedJdk" />
     <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="module-library" scope="TEST">
+      <library name="JUnit4">
+        <CLASSES>
+          <root url="jar://$APPLICATION_HOME_DIR$/lib/junit-4.12.jar!/" />
+          <root url="jar://$APPLICATION_HOME_DIR$/lib/hamcrest-core-1.3.jar!/" />
+        </CLASSES>
+        <JAVADOC />
+        <SOURCES />
+      </library>
+    </orderEntry>
   </component>
 </module>
\ No newline at end of file
diff -ru -x .git ../master/comp1110-ass2/.idea/misc.xml comp1110-ass2/.idea/misc.xml
--- ../master/comp1110-ass2/.idea/misc.xml	2016-10-16 20:56:26.278208910 +0800
+++ comp1110-ass2/.idea/misc.xml	2016-10-16 20:58:44.186691441 +0800
@@ -3,13 +3,6 @@
   <component name="EntryPointsManager">
     <entry_points version="2.0" />
   </component>
-  <component name="MavenImportPreferences">
-    <option name="generalSettings">
-      <MavenGeneralSettings>
-        <option name="mavenHome" value="Bundled (Maven 3)" />
-      </MavenGeneralSettings>
-    </option>
-  </component>
   <component name="ProjectLevelVcsManager" settingsEditedManually="false">
     <OptionsSetting value="true" id="Add" />
     <OptionsSetting value="true" id="Remove" />
Only in comp1110-ass2: META-INF
Only in comp1110-ass2: overall2.png
Only in comp1110-ass2: overall3.png
Only in comp1110-ass2: overall.png
Only in comp1110-ass2: presentation.pdf
Only in comp1110-ass2: presentation.ppt
Only in comp1110-ass2/src/comp1110/ass2/gui/assets: matchRule1.png
Only in comp1110-ass2/src/comp1110/ass2/gui/assets: matchRule2.png
Only in comp1110-ass2/src/comp1110/ass2/gui: Board$1.class
Only in comp1110-ass2/src/comp1110/ass2/gui: Board$2.class
Only in comp1110-ass2/src/comp1110/ass2/gui: Board$3.class
Only in comp1110-ass2/src/comp1110/ass2/gui: Board$4.class
Only in comp1110-ass2/src/comp1110/ass2/gui: Board$5.class
Only in comp1110-ass2/src/comp1110/ass2/gui: Board.class
diff -ru -x .git ../master/comp1110-ass2/src/comp1110/ass2/gui/Board.java comp1110-ass2/src/comp1110/ass2/gui/Board.java
--- ../master/comp1110-ass2/src/comp1110/ass2/gui/Board.java	2016-10-16 20:56:26.286208879 +0800
+++ comp1110-ass2/src/comp1110/ass2/gui/Board.java	2016-10-16 20:58:44.286696227 +0800
@@ -1,7 +1,37 @@
 package comp1110.ass2.gui;
 
+import comp1110.ass2.LinkGame;
+import javafx.animation.Animation;
+import javafx.animation.KeyFrame;
+import javafx.animation.Timeline;
 import javafx.application.Application;
+import javafx.event.ActionEvent;
+import javafx.event.EventHandler;
+import javafx.geometry.HPos;
+import javafx.geometry.Insets;
+import javafx.geometry.Orientation;
+import javafx.geometry.VPos;
+import javafx.scene.Group;
+import javafx.scene.Node;
+import javafx.scene.Scene;
+import javafx.scene.control.*;
+import javafx.scene.image.Image;
+import javafx.scene.input.KeyCode;
+import javafx.scene.layout.GridPane;
+import javafx.scene.layout.HBox;
+import javafx.scene.paint.Color;
+import javafx.scene.shape.Circle;
+import javafx.scene.shape.Line;
+import javafx.scene.text.Font;
+import javafx.scene.text.Text;
+import javafx.scene.text.TextAlignment;
 import javafx.stage.Stage;
+import javafx.util.Duration;
+
+import javafx.scene.image.ImageView;
+import java.io.*;
+import java.net.URL;
+import java.util.*;
 
 public class Board extends Application {
     private static final int BOARD_WIDTH = 933;
@@ -15,8 +45,935 @@
 
     // FIXME Task 12: Generate interesting starting placements
 
+
+    /* board layout */
+    private static final int SQUARE_SIZE = 100;
+    private static final int PIECE_IMAGE_SIZE = 3*SQUARE_SIZE;
+    private static final double ROW_HEIGHT = SQUARE_SIZE * 0.8660254; // 60 degrees
+    private static final int VIEWER_WIDTH = BOARD_WIDTH;
+    private static final int VIEWER_HEIGHT = BOARD_HEIGHT;
+    protected static final double PEGINTERVALX = 55;
+    protected static final double PIECESIZE = 3*PEGINTERVALX;
+
+    private static final int BUTTON_X = 458;
+    private static final int BUTTON_Y = 650;
+    private static final int BUTTON2_X = 550;
+    private static final int BUTTON2_Y = 650;
+    private static final int SLIDER_X = 313;
+    private static final int SLIDER_Y = 650;
+    private static final int SLIDER_CAPTION_X = 248;
+    private static final int SLIDER_CAPTION_Y = 650;
+    private static final int COMPLETION_TEXT_X = 240;
+    private static final int COMPLETION_TEXT_Y = 580;
+
+    private static final String URI_BASE = "assets/";
+
+    private static final Group root = new Group();
+    private static final Group controls = new Group();
+    private static final Group pegs = new Group();
+    private static final Group pieces = new Group();
+    private static final Group solution = new Group();
+    private final Slider difficulty = new Slider();
+    private static final Text completionText = new Text("Congratulation!");
+    private static Text timeRecorder = new Text("00:00:00");
+    private static Text displayRecord = new Text();
+    private static final Group startPieces = new Group();
+    private static Group help = new Group();
+
+    private static final Group rootAdv = new Group();
+    private static final Group advControls = new Group();
+    private static boolean isAdventure = false;
+    private static final Text failText = new Text("Try Again!");
+    private static final Text levelText = new Text();
+
+    private static String startString = "";
+    private static String theSolution = "";
+    private static final double opacity = 0.2;
+    private static boolean isComplete = false;
+    private static int timePlayed = 0;
+    private static double diff;
+    private static ArrayList<Record> records = new ArrayList<>();
+    private static Random ran = new Random();
+    //private static String nameString = "";
+
+    /*
+      By Hongbo,
+      class for record of this game
+     */
+    private static class Record {
+        public String recorder;
+        public int sec;
+        Record(String name, int time) {
+            recorder = name;
+            sec = time;
+        }
+    }
+
+    /**
+     * By Hongbo
+     * Draw a starting placement in the window, removing any previously drawn one,
+     * and draw the starting pieces at their home position as transparent.
+     */
+    private static void makeStartPlacement() {
+        if ( LinkGame.isPlacementValid(startString)) {
+            Draggable.presetPlacement(startString);
+            startPieces.getChildren().clear();
+            ArrayList<String> piecePlacements = breakPlacementString(startString);
+            for (int i = 0; i < piecePlacements.size(); i++) {
+                startPieces.getChildren().add(new NonDraggable(piecePlacements.get(i)));
+                NonDraggable tmp = new NonDraggable(piecePlacements.get(i).charAt(1),true);
+                tmp.setOpacity(opacity);
+                startPieces.getChildren().add(tmp);
+            }
+        }
+    }
+
+    /**
+     * By Hongbo
+     * break placement string into piece placement
+     * @param placement: a placement String
+     * @return: arrayList of piece placement string
+     */
+    public static ArrayList<String> breakPlacementString(String placement) {
+        ArrayList<String> piecePlacementStrings = new ArrayList<>();
+        if ( ! LinkGame.isPlacementWellFormed(placement) ) {
+            throw new RuntimeException("Bad input placement string: "+ placement);
+        } else {
+            for ( int i = 0; i<placement.length(); i=i+3) {
+                String thispiece = placement.substring(i,i+3);
+                if ( ! LinkGame.isPiecePlacementWellFormed(thispiece) ) {
+                    throw new RuntimeException("Bad pieceplacement string: "+thispiece);
+                } else {
+                    piecePlacementStrings.add(thispiece);
+                }
+            }
+        }
+        return piecePlacementStrings;
+    }
+
+
+    /**
+     * *  By Hongbo
+     *  generate solution of a game with given starting placement,
+     *  and put the solution to the Group solution.
+     *  if isRead, then read the solution from file.
+     *  if !isRead, then calculate the solution
+     * @param isRead
+     */
+    public static void makeSolution(boolean isRead) {
+        String solu = "";
+        if ( !isRead ) {
+            String[] solus = LinkGame.getSolutions(startString);
+            if (solus.length == 1) {
+                solu = solus[0];
+                Draggable.setSolution(solu);
+            }
+        } else if ( isRead ) {
+            solu = theSolution;
+            Draggable.setSolution(solu);
+        }
+        //System.out.println(solu);
+        solution.getChildren().clear();
+        ArrayList<String> piecePlacements = breakPlacementString(solu);
+        for (int i = 0; i < piecePlacements.size(); i++) {
+            NonDraggable tmp = new NonDraggable(piecePlacements.get(i));
+            //tmp.setOpacity(0);
+            solution.getChildren().add(tmp);
+        }
+        solution.setOpacity(0);
+    }
+
+    /**
+     * By Hongbo
+     * make short cut key of the game.
+     * "/" : show solution as a hint.
+     * @param scene : the scene of the primaryStage
+     */
+    public static void makeKeyShortCut(Scene scene) {
+        scene.setOnKeyPressed(event -> {
+            if ( event.getCode() == KeyCode.SLASH ) {
+                solution.setOpacity(1.0);
+                solution.toFront();
+                pieces.setOpacity(0);
+            }
+        });
+        scene.setOnKeyReleased(event -> {
+            if ( event.getCode() == KeyCode.SLASH ) {
+                solution.setOpacity(0);
+                solution.toBack();
+                pieces.setOpacity(1.0);
+            }
+        });
+    }
+
+    /**
+     * By Hongbo
+     * Create difficult slide bar, a restart button, a new game button and an adventure button
+     * for training mode
+     */
+    private void makeControls(Stage primaryStage, Scene scene,Scene advanScene) {
+
+        controls.getChildren().clear();
+
+        Button button = new Button("New Game");
+        button.setLayoutX(BUTTON_X);
+        button.setLayoutY(BUTTON_Y);
+        button.setOnAction(new EventHandler<ActionEvent>() {
+            @Override public void handle(ActionEvent e) {
+                newGame();
+            }
+        });
+        controls.getChildren().add(button);
+
+        Button button2 = new Button("Restart");
+        button2.setLayoutX(BUTTON2_X);
+        button2.setLayoutY(BUTTON2_Y);
+        button2.setOnAction(new EventHandler<ActionEvent>() {
+            @Override public void handle(ActionEvent e) {
+                restart();
+            }
+        });
+        controls.getChildren().add(button2);
+
+        Button toAdv = new Button("Adventure");
+        toAdv.setLayoutX(BUTTON2_X + 68);
+        toAdv.setLayoutY(BUTTON2_Y);
+        toAdv.setOnAction(new EventHandler<ActionEvent>() {
+            @Override
+            public void handle(ActionEvent event) {
+                initializeAdventure(primaryStage,scene,advanScene);
+            }
+        });
+        controls.getChildren().add(toAdv);
+
+        difficulty.setMin(1);
+        difficulty.setMax(8);
+        difficulty.setValue(1);
+        difficulty.setShowTickLabels(true);
+        difficulty.setShowTickMarks(true);
+        difficulty.setMajorTickUnit(1);
+        difficulty.setMinorTickCount(0);
+        difficulty.setSnapToTicks(true);
+
+        difficulty.setLayoutX(SLIDER_X);
+        difficulty.setLayoutY(SLIDER_Y);
+        controls.getChildren().add(difficulty);
+
+        final Label difficultyCaption = new Label("Difficulty:");
+        difficultyCaption.setTextFill(Color.GREY);
+        difficultyCaption.setLayoutX(SLIDER_CAPTION_X);
+        difficultyCaption.setLayoutY(SLIDER_CAPTION_Y);
+        controls.getChildren().add(difficultyCaption);
+    }
+
+    /**
+     * By Hongbo
+     * Create a restart button, and an training button
+     * for adventure mode
+     */
+    private void makeAdvControls(Stage primaryStage, Scene scene, Scene advanScene) {
+
+        advControls.getChildren().clear();
+
+        Button button2 = new Button("New Adventure");
+        button2.setLayoutX(220);
+        button2.setLayoutY(BUTTON2_Y);
+        button2.setOnAction(new EventHandler<ActionEvent>() {
+            @Override public void handle(ActionEvent e) {
+                newAdvGame();
+            }
+        });
+        advControls.getChildren().add(button2);
+
+        Button toFree = new Button("Training");
+        toFree.setLayoutX(480);
+        toFree.setLayoutY(BUTTON2_Y);
+        toFree.setOnAction(new EventHandler<ActionEvent>() {
+            @Override
+            public void handle(ActionEvent event) {
+                initializeFreeMode(primaryStage, scene, advanScene);
+            }
+        });
+        advControls.getChildren().add(toFree);
+    }
+
+    /**
+     * By Hongbo
+     * make timer, record the time / count down the time. and make a fancy animation after completing the game.
+     */
+    private static void makeTimer() {
+        Timeline timeline = new Timeline(new KeyFrame(Duration.millis(100),
+                ae -> {
+                    if ( !isAdventure ) {
+                        if (!isComplete) {
+                            timePlayed = timePlayed + 1;
+                        } else {
+                            solution.setOpacity(1.0);
+                            solution.toFront();
+                            pieces.setOpacity(0);
+                            startPieces.setOpacity(0);
+                            pegs.setOpacity(0);
+                            for (Node p : solution.getChildren()) {
+                                NonDraggable tmp = (NonDraggable) p;
+                                tmp.setFitWidth((2 * (ran.nextDouble() - 0.5) + 1) * PIECESIZE);
+                                tmp.setFitWidth((2 * (ran.nextDouble() - 0.5) + 1) * PIECESIZE);
+                            }
+                        }
+                        root.getChildren().remove(timeRecorder);
+                        timeRecorder.setText(toTimeString(timePlayed / 10));
+                        timeRecorder.setFill(Color.BLACK);
+                        timeRecorder.setFont(Font.font("Arial", 40));
+                        timeRecorder.setLayoutX(SQUARE_SIZE * 2.5);
+                        timeRecorder.setLayoutY(ROW_HEIGHT * 0.75);
+                        timeRecorder.setTextAlignment(TextAlignment.CENTER);
+                        root.getChildren().add(timeRecorder);
+                    } else {
+                        if ( !isComplete ) {
+                            timePlayed = timePlayed - 1;
+                            if ( timePlayed < 0 ) {
+                                showFail();
+                            }
+                        } else {
+                            solution.setOpacity(1.0);
+                            solution.toFront();
+                            pieces.setOpacity(0);
+                            startPieces.setOpacity(0);
+                            pegs.setOpacity(0);
+                            for ( Node p : solution.getChildren() ) {
+                                NonDraggable tmp = (NonDraggable) p;
+                                tmp.setFitWidth( (2*(ran.nextDouble()-0.5)+1)*PIECESIZE);
+                                tmp.setFitWidth( (2*(ran.nextDouble()-0.5)+1)*PIECESIZE );
+                            }
+                        }
+                        rootAdv.getChildren().remove(timeRecorder);
+                        timeRecorder.setText(toTimeString(timePlayed/10));
+                        timeRecorder.setFill(Color.BLACK);
+                        timeRecorder.setFont(Font.font("Arial",40));
+                        timeRecorder.setLayoutX(SQUARE_SIZE*2.5);
+                        timeRecorder.setLayoutY(ROW_HEIGHT*0.75);
+                        timeRecorder.setTextAlignment(TextAlignment.CENTER);
+                        rootAdv.getChildren().add(timeRecorder);
+                    }
+                }));
+        timeline.setCycleCount(Animation.INDEFINITE);
+        if ( isComplete ) {
+            timeline.stop();
+        } else {
+            timeline.play();
+        }
+    }
+
+    /**
+     * By Hongbo
+     * make timer, count down the time, and make a fancy animation after completing the game for adventure mode only
+     * not used any more.
+     */
+    private static void makeAdvTimer() {
+        Timeline timelineAdv = new Timeline(new KeyFrame(Duration.millis(100),
+                ae -> {
+                    if ( !isComplete ) {
+                        timePlayed = timePlayed - 1;
+                        if ( timePlayed < 0 ) {
+                            showFail();
+                        }
+                    } else {
+                        solution.setOpacity(1.0);
+                        solution.toFront();
+                        pieces.setOpacity(0);
+                        startPieces.setOpacity(0);
+                        pegs.setOpacity(0);
+                        for ( Node p : solution.getChildren() ) {
+                            NonDraggable tmp = (NonDraggable) p;
+                            tmp.setFitWidth( (2*(ran.nextDouble()-0.5)+1)*PIECESIZE);
+                            tmp.setFitWidth( (2*(ran.nextDouble()-0.5)+1)*PIECESIZE );
+                        }
+                    }
+                    rootAdv.getChildren().remove(timeRecorder);
+                    timeRecorder.setText(toTimeString(timePlayed/10));
+                    timeRecorder.setFill(Color.BLACK);
+                    timeRecorder.setFont(Font.font("Arial",40));
+                    timeRecorder.setLayoutX(SQUARE_SIZE*2.5);
+                    timeRecorder.setLayoutY(ROW_HEIGHT*0.75);
+                    timeRecorder.setTextAlignment(TextAlignment.CENTER);
+                    rootAdv.getChildren().add(timeRecorder);
+                }));
+        timelineAdv.setCycleCount(Animation.INDEFINITE);
+        if ( isComplete ) {
+            timelineAdv.stop();
+        } else {
+            timelineAdv.play();
+        }
+    }
+
+    /**
+     * By Hongbo
+     * make the GUI part of scoring system
+     */
+    private static void makeRecord() {
+        root.getChildren().remove(displayRecord);
+        String tmp = "";
+        for ( int i = 0; i < records.size(); i++) {
+            String formatTmp = formatName(records.get(i).recorder);
+            tmp = tmp + formatTmp + "  " + toTimeString(records.get(i).sec) + "\n";
+        }
+        //System.out.println(tmp);
+        displayRecord.setText(tmp);
+        displayRecord.setFill(Color.BLACK);
+        displayRecord.setFont(Font.font("Arial",20));
+        displayRecord.setLayoutX(0.2*SQUARE_SIZE);
+        displayRecord.setLayoutY(ROW_HEIGHT*5.5);
+        displayRecord.setTextAlignment(TextAlignment.RIGHT);
+        root.getChildren().add(displayRecord);
+    }
+
+    /**
+     * By Hongbo
+     * format output of names
+     * @param name
+     * @return 10 character long string. if name.length > 10, then trunct, if < 10, use space
+     */
+    private static String formatName(String name) {
+        String rt = name;
+        if ( name == null ) {
+            return "Anonymous ";
+        } else if ( name.length() > 10 ) {
+            rt = name.substring(0,10);
+        } else {
+            for ( int i = 0; i<10-name.length();i++) {
+                rt = rt + " ";
+                //System.out.println(rt+"|");
+            }
+        }
+        return rt;
+    }
+
+    /**
+     * By Hongbo
+     * transfer seconds to the formation of hh:mm:ss
+     * @param seconds
+     * @return a string of format hh:mm:ss
+     */
+    private static String toTimeString(int seconds) {
+        int hours = seconds / 3600;
+        int mins = (seconds - 3600*hours) / 60;
+        int secs = seconds - 3600*hours - 60*mins;
+        return String.format("%02d:%02d:%02d",hours,mins,secs);
+    }
+
+    /**
+     * By Hongbo
+     * restart the game when click the "restart" button on GUI:
+     * reset the String placement in Draggable class
+     * put all the non-starting pieces to their home position
+     */
+    private static void restart() {
+        isComplete = false;
+        timePlayed = 0;
+        completionText.setOpacity(0);
+        solution.setOpacity(0);
+        solution.toBack();
+        pieces.setOpacity(1.0);
+        startPieces.setOpacity(1.0);
+        pegs.setOpacity(1.0);
+        Draggable.presetPlacement(startString);
+        for ( Node n : pieces.getChildren() ) {
+            ((Draggable) n).snapToHome();
+        }
+        readRecord((int)Math.round(diff));
+        makeRecord();
+    }
+
+    /**
+     * By Hongbo
+     * start a new game in training mode when click "new game" button on GUI:
+     * read the difficulty from the slider, generate a starting placement,
+     * put lots Groups on the GUI, set the completion notification transparent.
+     */
+    private void newGame() {
+        isComplete = false;
+        timePlayed = 0;
+        diff = difficulty.getValue();
+        solution.setOpacity(0);
+        solution.toBack();
+        pieces.setOpacity(1.0);
+        startPieces.setOpacity(1.0);
+        pegs.setOpacity(1.0);
+        setUpStartString(diff);
+        makeStartPlacement();
+        makePieces();
+        makeSolution(true);
+        completionText.setOpacity(0);
+        readRecord((int)Math.round(diff));
+        makeRecord();
+    }
+
+    /**
+     * By Hongbo
+     * start a new game in adventure mode
+     */
+    private static void newAdvGame() {
+        isComplete = false;
+        timePlayed = 18000;
+        diff = 1;
+        levelText.setOpacity(1);
+        solution.setOpacity(0);
+        solution.toBack();
+        pieces.setOpacity(1.0);
+        startPieces.setOpacity(1.0);
+        pegs.setOpacity(1.0);
+        setUpStartString(diff);
+        makeStartPlacement();
+        makePieces();
+        makeSolution(true);
+        completionText.setOpacity(0);
+        failText.setOpacity(0);
+    }
+
+    /**
+     * By Hongbo
+     * start a new game in adventure mode with a given difficulty
+     * @param difficulty
+     */
+    private static void newAdvGame(double difficulty) {
+        isComplete = false;
+        levelText.setOpacity(1);
+        diff = difficulty;
+        solution.setOpacity(0);
+        solution.toBack();
+        pieces.setOpacity(1.0);
+        startPieces.setOpacity(1.0);
+        pegs.setOpacity(1.0);
+        setUpStartString(diff);
+        makeStartPlacement();
+        makePieces();
+        makeSolution(true);
+        completionText.setOpacity(0);
+        failText.setOpacity(0);
+    }
+
+    /**
+     * By Hongbo
+     * read the record of a given difficulty level from file
+     * @param diffi
+     */
+    private static void readRecord(int diffi) {
+        try {
+            String Directory = System.getProperty("user.dir");
+            ArrayList<String> names = new ArrayList<>();
+            ArrayList<Integer> seconds = new ArrayList<>();
+            String path = Directory + "/src/comp1110/ass2/SolutionDictionary/record.txt";
+            File filename = new File(path);
+            InputStreamReader reader = new InputStreamReader(new FileInputStream(filename));
+            BufferedReader br = new BufferedReader(reader);
+            String line = "";
+            line = br.readLine();
+            while (line != null) {
+                Scanner thisLine = new Scanner(line);
+                names.add(thisLine.next());
+                seconds.add(thisLine.nextInt());
+                line = br.readLine();
+            }
+            br.close();
+            records.clear();
+            for ( int i = 0; i < 10; i++) {
+                Record tmp = new Record(names.get(10*(diffi-1)+i),seconds.get(10*(diffi-1)+i));
+                records.add(tmp);
+            }
+        } catch (Exception exc) {
+            exc.printStackTrace();
+        }
+    }
+
+    /**
+     * By Hongbo
+     * If some one breaks the record, then record it
+     * @param diffi
+     */
+    private static void updateRecord(int diffi) {
+        int ind = 100;
+        for ( int i = 0; i < 10; i++ ) {
+            if ( timePlayed/10 < records.get(i).sec ) {
+                ind = i;
+                break;
+            }
+        }
+        if ( ind < 10 ) {
+
+            TextInputDialog grid = new TextInputDialog("anonym.");
+            grid.getEditor();
+            //grid.initOwner(parent);
+            grid.setTitle("Input your name");
+            grid.setContentText("Your Name");
+            grid.setHeaderText("Congratulations!\nYou become the top player!");
+            Optional<String> nameString = grid.showAndWait();
+
+            //records.add(ind,new Record("Hongbo",timePlayed));
+            if ( ! nameString.isPresent() || nameString.get().equals("") || nameString.get().equals(" ") ) {
+                records.add(ind, new Record("anonym.", timePlayed/10));
+            } else {
+                records.add(ind, new Record(nameString.get(), timePlayed/10));
+            }
+            records.remove(records.size()-1);
+
+            try {
+                RandomAccessFile writeRecord = new RandomAccessFile("src/comp1110/ass2/SolutionDictionary/record.txt","rw");
+                for ( int i = 0; i < (diffi-1)*10; i++ ) {
+                    writeRecord.readLine();
+                }
+                for ( int i = 0; i < 10; i++) {
+                    String willWrite = String.format("%-13s%6d%n",records.get(i).recorder,records.get(i).sec);
+                    //writeRecord.writeChars(willWrite);
+                    for ( int j = 0; j < willWrite.length(); j++) {
+                        writeRecord.write(willWrite.charAt(j));
+                    }
+                    //writeRecord.writeChar('\n');
+                }
+                writeRecord.close();
+            } catch (Exception exc) {
+                exc.printStackTrace();
+            }
+        }
+    }
+
+    /**
+     * By Hongbo
+     * show the completion notification on the GUI
+     */
+    protected static void showCompletion() {
+    //protected void showCompletion() {
+        if ( ! isAdventure ) {
+            completionText.setOpacity(1);
+            isComplete = true;
+            //a window for input username
+            updateRecord((int) Math.round(diff));
+            makeRecord();
+        } else {
+            int diffInt = (int) Math.round(diff);
+            if ( diffInt < 8 ) {
+                diff = diff + 1;
+                newAdvGame(diff);
+                diffInt++;
+                levelText.setText("LEVEL "+diffInt);
+            } else {
+                completionText.setOpacity(1);
+                isComplete = true;
+                levelText.setOpacity(0);
+            }
+        }
+    }
+
+    /**
+     * By Hongbo
+     * put completion notification on the GUI
+     */
+    private static void makeCompletion() {
+        completionText.setFill(Color.BLACK);
+        completionText.setFont(Font.font("Arial", 60));
+        completionText.setLayoutX(COMPLETION_TEXT_X);
+        completionText.setLayoutY(COMPLETION_TEXT_Y);
+        completionText.setTextAlignment(TextAlignment.CENTER);
+        root.getChildren().add(completionText);
+    }
+
+    /**
+     * By Hongbo
+     * make the fail notification in adventure mode
+     */
+    private static void makeFail(){
+        failText.setFill(Color.BLACK);
+        failText.setFont(Font.font("Arial", 80));
+        failText.setLayoutX(COMPLETION_TEXT_X);
+        failText.setLayoutY(COMPLETION_TEXT_Y);
+        failText.setTextAlignment(TextAlignment.CENTER);
+        rootAdv.getChildren().add(failText);
+    }
+
+    /**
+     * By Hongbo
+     * notify in GUI when user fails in adventure mode
+     */
+    private static void showFail(){
+        failText.setOpacity(1);
+        isComplete = true;
+        pieces.setOpacity(0);
+        levelText.setOpacity(0);
+    }
+
+    /**
+     * By Hongbo
+     * make the completion notificatioin in adventure mode
+     */
+    private static void makeCompletionAdv() {
+        completionText.setFill(Color.BLACK);
+        completionText.setFont(Font.font("Arial", 80));
+        completionText.setLayoutX(COMPLETION_TEXT_X);
+        completionText.setLayoutY(COMPLETION_TEXT_Y);
+        completionText.setTextAlignment(TextAlignment.CENTER);
+        rootAdv.getChildren().add(completionText);
+    }
+
+    /**
+     *  By Hongbo
+     *  create the peg array. 24 pegs
+     */
+    public static void makePegArray() {
+        PegArray viewerPegArray = new PegArray();
+        viewerPegArray.setUpPegCircle();
+        pegs.getChildren().clear();
+        for ( int i = 0; i < 24; i++) {
+            pegs.getChildren().add(viewerPegArray.pegCircle.get(i));
+        }
+    }
+
+    /**
+     * By Hongbo
+     * ('A..L') - (the pieces in startString)
+     * @return the non-starting pieces
+     */
+    private static String getRemainingPieces() {
+        String remainPiecesString;
+        remainPiecesString = "ABCDEFGHIJKL";
+        for ( int i = 1; i < startString.length(); i = i+3) {
+            //System.out.println("i = "+i+"; piece is "+startString.charAt(i));
+            remainPiecesString = remainPiecesString.replace(startString.charAt(i)+"","");
+        }
+        //System.out.println(remainPiecesString);
+        return remainPiecesString;
+    }
+
+    /**
+     * By Hongbo
+     * help for new users
+     */
+    private static void makeHelp() {
+        help.getChildren().clear();
+        Text helpText = new Text();
+        String tmp ="";
+        if ( !isAdventure ) {
+            tmp = "HELP: training mode\n\nI. operation\n\n1. transparent ones are\n    not draggable.\n2. drag the piece to\n    move and snap\n" +
+                    "3. right click to flip\n4. scroll to rotate\n5. press \"\\\" for hint.\n" +
+                    "6. press restart btn\n    to restart.\n7. press newGame btn\n    for a new game.\n8. use slider for\n    other difficulty\n" +
+                    "9. press adventure btn\n    to adventure mode.\n" +
+                    "\nII. matching rules\n";
+        } else {
+            tmp = "HELP: adventure mode.\n\n\nIT'S COUNTING DOWN!\n\n\nI. operation\n\n1. transparent ones are\n    not draggable.\n2. drag the piece to\n    move and snap\n" +
+                    "3. right click to flip\n4. scroll to rotate\n5. press \"\\\" for hint.\n" +
+                    "6. press new adventure\n    btn to restart.\n" +
+                    "7. press training btn\n    to training mode.\n" +
+                    "\nII. matching rules\n";
+        }
+        helpText.setText(tmp);
+        helpText.setFill(Color.BLACK);
+        helpText.setFont(Font.font("Arial", 16));
+        helpText.setLayoutX(725);
+        helpText.setLayoutY(30);
+        helpText.setTextAlignment(TextAlignment.LEFT);
+
+        URL url1 = Draggable.class.getResource(URI_BASE + "matchRule1.png");
+        ImageView rule1 = new ImageView();
+        URL url2 = Draggable.class.getResource(URI_BASE + "matchRule2.png");
+        ImageView rule2 = new ImageView();
+        rule1.setImage(new Image(url1.toString()));
+        rule2.setImage(new Image(url2.toString()));
+        rule1.setFitHeight(144);
+        rule1.setFitWidth(200);
+        rule1.setX(725);
+        rule1.setY(420);
+        rule2.setFitHeight(133);
+        rule2.setFitWidth(200);
+        rule2.setX(725);
+        rule2.setY(570);
+        help.getChildren().addAll(helpText,rule1,rule2);
+    }
+
+    /**
+     * By Hongbo
+     * initialize the game. put the (12 - start) pieces, i.e. non-Starting pieces, on their home positions
+     */
+    public static void makePieces() {
+        pieces.getChildren().clear();
+        String remainingPieces = getRemainingPieces();
+        for ( int i = 0; i < remainingPieces.length() ; i++) {
+            pieces.getChildren().add(new Draggable(remainingPieces.charAt(i),true));
+        }
+    }
+
+    /**
+     * By Hongbo
+     * for debug, no longer used
+     * 8 level difficulty.
+     * level 1 is easiest: 11 pieces are given in the startString.
+     * level 8 is the hardest: 4 pieces are given in the startString.
+     * level x : (12-x) pieces are given in the startString.
+     * @param difficulty the difficult level of the game
+     */
+    private static void setUpStartStringTest(double difficulty) {
+        diff = (int)Math.round(difficulty);
+        if ( diff == 1 ) {
+            startString = "KAFCBGUCAGDFLEFPFBBGESHBWIJKJAHKL";
+        } else if ( diff == 2 ) {
+            startString = "KAFCBGUCAGDFLEFPFBBGESHBWIJKJA";
+        } else if ( diff == 3 ) {
+            startString = "KAFCBGUCAGDFLEFPFBBGESHBOIA";
+        } else if ( diff == 4 ) {
+            startString = "KAFTBAICFRDCEELWFJJGDMHK";
+        } else if ( diff == 5 ) {
+             startString = "JABHBCBCGGDFIEKVFAFGG";
+        } else if ( diff == 6 ) {
+             startString = "JACRBHQCHCDGDELVFJ";
+        } else if ( diff == 7 ) {
+            startString = "IAFBBDRCEPDEWEB";
+        } else if ( diff == 8 ) {
+            startString = "GAEWBABCDJDA";
+        }
+    }
+
+    /**
+     * By Hongbo
+     * 8 level difficulty.
+     * level 1 is easiest: 11 pieces are given in the startString.
+     * level 8 is the hardest: 4 pieces are given in the startString.
+     * level x : (12-x) pieces are given in the startString.
+     * @param difficulty the difficult level of the game
+     */
+    private static void setUpStartString(double difficulty) {
+        int diffi = (int)Math.round(difficulty);
+
+        try {
+            String Directory = System.getProperty("user.dir");
+            ArrayList<String> pieces = new ArrayList<>();
+            ArrayList<String> sols = new ArrayList<>();
+            String path = Directory + "/src/comp1110/ass2/SolutionDictionary/diff0" + diffi + ".txt";
+            File filename = new File(path);
+            InputStreamReader reader = new InputStreamReader(new FileInputStream(filename));
+            BufferedReader br = new BufferedReader(reader);
+            String line = "";
+            line = br.readLine();
+            while (line != null) {
+                Scanner thisLine = new Scanner(line);
+                pieces.add(thisLine.next());
+                sols.add(thisLine.next());
+                line = br.readLine();
+            }
+
+            int totalLength = pieces.size();
+            Random ran = new Random();
+            int index = ran.nextInt(totalLength);
+            startString = pieces.get(index);
+            theSolution = sols.get(index);
+            br.close();
+        } catch (Exception exc) {
+            exc.printStackTrace();
+        }
+    }
+
+    /**
+     * initialization method of adventure mode
+     * @param primaryStage
+     * @param scene
+     * @param advanScene
+     */
+    private void initializeAdventure(Stage primaryStage, Scene scene, Scene advanScene) {
+        isAdventure = true;
+        rootAdv.getChildren().clear();
+        rootAdv.getChildren().add(advControls);
+        rootAdv.getChildren().add(pegs);
+        rootAdv.getChildren().add(startPieces);
+        rootAdv.getChildren().add(pieces);
+        rootAdv.getChildren().add(solution);
+        rootAdv.getChildren().add(help);
+        //makeAdvTimer();
+        makeAdvControls(primaryStage,scene,advanScene);
+        makeKeyShortCut(advanScene);
+        makeCompletionAdv();
+        makeHelp();
+        makeFail();
+        newAdvGame();
+        primaryStage.setScene(advanScene);
+
+        levelText.setText("LEVEL 1");
+        levelText.setFill(Color.BLACK);
+        levelText.setFont(Font.font("Arial", 80));
+        levelText.setLayoutX(COMPLETION_TEXT_X);
+        levelText.setLayoutY(COMPLETION_TEXT_Y);
+        levelText.setTextAlignment(TextAlignment.CENTER);
+        rootAdv.getChildren().add(levelText);
+
+        // separators
+        Line r1 = new Line(720,15,720,685);
+        r1.setStrokeWidth(2);
+        r1.setStroke(Color.GRAY);
+        Line l1 = new Line(15,440,715,440);
+        l1.setStrokeWidth(2);
+        l1.setStroke(Color.GRAY);
+        rootAdv.getChildren().addAll(r1,l1);
+    }
+
+    /**
+     * initialization method of training mode
+     * @param primaryStage
+     * @param scene
+     * @param advanScene
+     */
+    private void initializeFreeMode(Stage primaryStage, Scene scene, Scene advanScene) {
+        isAdventure = false;
+        root.getChildren().clear();
+        root.getChildren().add(controls);
+        root.getChildren().add(pegs);
+        root.getChildren().add(startPieces);
+        root.getChildren().add(pieces);
+        root.getChildren().add(solution);
+        root.getChildren().add(help);
+        //makeTimer();
+        makeControls(primaryStage,scene,advanScene);
+        makeKeyShortCut(scene);
+        makePegArray();
+        makeCompletion();
+        makeHelp();
+        newGame();
+        primaryStage.setScene(scene);
+
+        // separators
+        Line r1 = new Line(720,15,720,685);
+        r1.setStrokeWidth(2);
+        //r1.setStroke(Color.web("000000"));
+        r1.setStroke(Color.GRAY);
+        Line l1 = new Line(15,440,715,440);
+        l1.setStrokeWidth(2);
+        l1.setStroke(Color.GRAY);
+        Line l2 = new Line(235,445,235,685);
+        l2.setStrokeWidth(2);
+        l2.setStroke(Color.GRAY);
+        root.getChildren().addAll(r1,l1,l2);
+        /*
+        Separator r1 = new Separator(Orientation.VERTICAL);
+        r1.setMaxHeight(700);
+        r1.setHalignment(VPos.CENTER);
+        root.getChildren().add(r1);
+        */
+    }
+
+    /**
+     * By Hongbo
+     * The main GUI
+     * @param primaryStage
+     * @throws Exception
+     */
     @Override
     public void start(Stage primaryStage) throws Exception {
+        primaryStage.setTitle("IQLink by thu11l");
+        Scene scene = new Scene(root, VIEWER_WIDTH, VIEWER_HEIGHT);
+        Scene advanScene = new Scene(rootAdv, VIEWER_WIDTH, VIEWER_HEIGHT);
+
+        //Draggable.linkedToBoard(this);
+        makeTimer();
+        // adds all the Groups to root ( free play mode)
+        // show free play mode as default
+        initializeFreeMode(primaryStage,scene,advanScene);
+
+        // adds all the groups to rootAdv (adventure mode)
+        // not default
 
+        primaryStage.show();
     }
 }
Only in comp1110-ass2/src/comp1110/ass2/gui: Board$Record.class
Only in comp1110-ass2/src/comp1110/ass2/gui: Draggable.class
Only in comp1110-ass2/src/comp1110/ass2/gui: Draggable.java
Only in comp1110-ass2/src/comp1110/ass2/gui: NonDraggable.class
Only in comp1110-ass2/src/comp1110/ass2/gui: NonDraggable.java
Only in comp1110-ass2/src/comp1110/ass2/gui: PegArray$Cartesian.class
Only in comp1110-ass2/src/comp1110/ass2/gui: PegArray.class
Only in comp1110-ass2/src/comp1110/ass2/gui: PegArray.java
Only in comp1110-ass2/src/comp1110/ass2/gui: Viewer$1.class
Only in comp1110-ass2/src/comp1110/ass2/gui: Viewer.class
diff -ru -x .git ../master/comp1110-ass2/src/comp1110/ass2/gui/Viewer.java comp1110-ass2/src/comp1110/ass2/gui/Viewer.java
--- ../master/comp1110-ass2/src/comp1110/ass2/gui/Viewer.java	2016-10-16 20:56:26.286208879 +0800
+++ comp1110-ass2/src/comp1110/ass2/gui/Viewer.java	2016-10-16 20:58:44.286696227 +0800
@@ -1,5 +1,6 @@
 package comp1110.ass2.gui;
 
+import comp1110.ass2.LinkGame;
 import javafx.application.Application;
 import javafx.event.ActionEvent;
 import javafx.event.EventHandler;
@@ -10,6 +11,7 @@
 import javafx.scene.control.TextField;
 import javafx.scene.layout.HBox;
 import javafx.stage.Stage;
+import java.util.ArrayList;
 
 /**
  * A very simple viewer for piece placements in the link game.
@@ -31,16 +33,48 @@
 
     private final Group root = new Group();
     private final Group controls = new Group();
+    private final Group pegs = new Group();
+    private final Group pieces = new Group();
     TextField textField;
 
+    //private LinkGame viewerLinkGame = new LinkGame();
 
     /**
+     * By Hongbo
      * Draw a placement in the window, removing any previously drawn one
-     *
      * @param placement  A valid placement string
      */
     void makePlacement(String placement) {
         // FIXME Task 5: implement the simple placement viewer
+        pieces.getChildren().clear();
+        ArrayList<String> piecePlacements = breakPlacementString(placement);
+        for ( int i = 0; i < piecePlacements.size(); i++) {
+            pieces.getChildren().add(new Draggable(piecePlacements.get(i)));
+        }
+
+    }
+
+    /**
+     * By Hongbo
+     * break placement string into piece placement
+     * @param placement
+     * @return: arrayList of piece placement string
+     */
+    public ArrayList<String> breakPlacementString(String placement) {
+        ArrayList<String> piecePlacementStrings = new ArrayList<>();
+        if ( ! LinkGame.isPlacementWellFormed(placement) ) {
+            throw new RuntimeException("Bad input placement string: "+ placement);
+        } else {
+            for ( int i = 0; i<placement.length(); i=i+3) {
+                String thispiece = placement.substring(i,i+3);
+                if ( ! LinkGame.isPiecePlacementWellFormed(thispiece) ) {
+                    throw new RuntimeException("Bad pieceplacement string: "+thispiece);
+                } else {
+                    piecePlacementStrings.add(thispiece);
+                }
+            }
+        }
+        return piecePlacementStrings;
     }
 
 
@@ -67,15 +101,77 @@
         controls.getChildren().add(hb);
     }
 
+    /**
+     * By Hongbo
+     * create the peg array. 24 pegs
+     */
+    public  void makePegArray() {
+        PegArray viewerPegArray = new PegArray();
+        viewerPegArray.setUpPegCircle();
+        for ( int i = 0; i < 24; i++) {
+            pegs.getChildren().add(viewerPegArray.pegCircle.get(i));
+        }
+    }
+
+    /**
+     * By Hongbo
+     * initialize the game. put the 12 pieces on their home positions
+     */
+    public  void makePieces() {
+        pieces.getChildren().clear();
+        for ( char ch = 'A'; ch <= 'L'; ch++) {
+            pieces.getChildren().add(new Draggable(ch,true));
+        }
+    }
+
+    /**
+     * By Hongbo
+     * used for debug, not used any longer
+     * put the 12 pieces on the given position with default orientation
+     */
+    public void makePiecesWithOrigin() {
+        pieces.getChildren().clear();
+        for ( char ch = 'A'; ch <= 'L'; ch++) {
+            pieces.getChildren().add(new Draggable(ch,ch));
+        }
+    }
+
+    /**
+     * By Hongbo
+     * used for debug, not used any longer
+     * put the 12 pieces on the given position with given orientation
+     */
+    public void makePiecesWithOriginAndRotation() {
+        pieces.getChildren().clear();
+        for ( char ch = 'A'; ch <= 'L'; ch++) {
+            char[] pieceChar = {ch,ch,ch};
+            String piece = new String(pieceChar);
+            pieces.getChildren().add(new Draggable(piece));
+        }
+    }
+
+    /**
+     * By Hongbo
+     * main GUI of viewer
+     * @param primaryStage
+     * @throws Exception
+     */
     @Override
     public void start(Stage primaryStage) throws Exception {
         primaryStage.setTitle("LinkGame Viewer");
         Scene scene = new Scene(root, VIEWER_WIDTH, VIEWER_HEIGHT);
 
         root.getChildren().add(controls);
-
         makeControls();
 
+        root.getChildren().add(pegs);
+        makePegArray();
+
+        root.getChildren().add(pieces);
+        makePieces();
+        //makePiecesWithOrigin(); // for test
+        //makePiecesWithOriginAndRotation(); // for test
+
         primaryStage.setScene(scene);
         primaryStage.show();
     }
Only in comp1110-ass2/src/comp1110/ass2: LinkGame.class
diff -ru -x .git ../master/comp1110-ass2/src/comp1110/ass2/LinkGame.java comp1110-ass2/src/comp1110/ass2/LinkGame.java
--- ../master/comp1110-ass2/src/comp1110/ass2/LinkGame.java	2016-10-16 20:56:26.286208879 +0800
+++ comp1110-ass2/src/comp1110/ass2/LinkGame.java	2016-10-16 20:58:44.242694121 +0800
@@ -1,44 +1,122 @@
 package comp1110.ass2;
 
+import javafx.collections.ArrayChangeListener;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+
 /**
  * This class provides the text interface for the Link Game
- *
+ * <p>
  * The game is based directly on Smart Games' IQ-Link game
  * (http://www.smartgames.eu/en/smartgames/iq-link)
  */
 public class LinkGame {
 
+    //static HashMap<Integer,ArrayList<UandO>> occupationArray = new HashMap<>(); // record occupation status of each peg
+    static HashMap<Integer, ArrayList<String>> occupationArray = new HashMap<>(); // record occupation status of each peg
+    //static HashMap<Integer, ArrayList<String>> lastOccupationArray = new HashMap<>(); // record the last occupationArray
+    static int[] pegIndex = new int[3]; // record the peg index occupied by the last placed piece
+    static long totalDeepCopyTime = 0;
+    static int callIsPlacementValid = 0;
+
     /**
+     * By Yifan
      * Determine whether a piece placement is well-formed according to the following:
      * - it consists of exactly three characters
      * - the first character is in the range A .. X
      * - the second character is in the range A .. L
      * - the third character is in the range A .. F if the second character is A, otherwise
-     *   in the range A .. L
+     * in the range A .. L
      *
      * @param piecePlacement A string describing a piece placement
      * @return True if the piece placement is well-formed
      */
-    static boolean isPiecePlacementWellFormed(String piecePlacement) {
+    public static boolean isPiecePlacementWellFormed(String piecePlacement) {
+        int x = piecePlacement.length();
+        char a = piecePlacement.charAt(0);
+        char b = piecePlacement.charAt(1);
+        char c = piecePlacement.charAt(2);
+        String s1 = "ABCDEFGHIJKLMNOPQRSTUVWX";
+        String s2 = "ABCDEFGHIJKL";
+        String s3 = "ABCDEFGHIJKL";
+        String s4 = "ABCDEF";
+        boolean b1 = Character.isUpperCase(a) && Character.isUpperCase(b) && Character.isUpperCase(c);
+        int i1 = s1.indexOf(a);
+        int i2 = s2.indexOf(b);
+        int i3 = s3.indexOf(c);
+        int i4 = s4.indexOf(c);
+        if (b == 'A') {
+            return (x == 3 && i1 >= 0 && i2 >= 0 && i4 >= 0 && b1);
+        }
         // FIXME Task 3: determine whether a piece placement is well-formed
-        return false;
+        else {
+            return (x == 3 && i1 >= 0 && i2 >= 0 && i3 >= 0 && b1);
+        }
     }
 
     /**
+     * By Shijie
      * Determine whether a placement string is well-formed:
-     *  - it consists of exactly N three-character piece placements (where N = 1 .. 12);
-     *  - each piece placement is well-formed
-     *  - no piece appears more than once in the placement
+     * - it consists of exactly N three-character piece placements (where N = 1 .. 12);
+     * - each piece placement is well-formed
+     * - no piece appears more than once in the placement
      *
      * @param placement A string describing a placement of one or more pieces
      * @return True if the placement is well-formed
      */
-    static boolean isPlacementWellFormed(String placement) {
-        // FIXME Task 4: determine whether a placement is well-formed
-        return false;
+    public static boolean isPlacementWellFormed(String placement) {
+        // FIXME Task 4: determine whether a placement is well-forme
+
+        String a = "";
+        String b = "";
+
+        //testempty
+        if (placement == null || placement.length() == 0) {
+            return false;
+        } else {
+
+            for (int i = 0; i < placement.length(); i++) {
+                if ((int) placement.charAt(i) >= (int) 'A' && (int) placement.charAt(i) <= (int) 'X') {
+                    a = a + placement.charAt(i);
+                }
+            }
+
+            //testbad
+            if (placement.equals(a) == false) {
+                return false;
+            } else {
+
+                //testincomplete
+                if (placement.length() % 3 != 0) {
+                    return false;
+                } else {
+
+                    for (int i = 1; i < placement.length(); i = i + 3) {
+                        if (b.contains(placement.charAt(i) + "") == false) {
+                            b = b + placement.charAt(i);
+                        }
+                    }
+
+                    //testduplicate
+                    if (b.length() == placement.length() / 3) {
+                        return true;
+                    } else return false;
+                }
+            }
+        }
     }
 
     /**
+     * By Hongbo
+     * The order of units in a piece: in its 0-rotation state:
+     * left-most is indexed 0
+     * origin of a piece ( middle) is indexed 1
+     * the right unit (in A B C) and the upper unit ( in D ... L) is indexed 2.
      * Return a array of peg locations according to which pegs the given piece placement touches.
      * The values in the array should be ordered according to the units that constitute the
      * piece.
@@ -51,31 +129,2017 @@
      */
     static int[] getPegsForPiecePlacement(String piecePlacement) {
         // FIXME Task 6: determine the pegs touched by a piece placement
-        return null;
+        char origin = piecePlacement.charAt(0);
+        char piece = piecePlacement.charAt(1);
+        char orient = piecePlacement.charAt(2);
+        int[] pegsIndex = new int[3];
+
+        HashSet<Character> iShape = new HashSet<>(); // I shape piece: A, B, C
+        iShape.add('A');
+        iShape.add('B');
+        iShape.add('C');
+        HashSet<Character> oShape = new HashSet<>(); // obtuse angle piece: D E F G H
+        oShape.add('D');
+        oShape.add('E');
+        oShape.add('F');
+        oShape.add('G');
+        oShape.add('H');
+        HashSet<Character> aShape = new HashSet<>(); // acute angle piece: I J K L
+        aShape.add('I');
+        aShape.add('J');
+        aShape.add('K');
+        aShape.add('L');
+
+        for (int i = 0; i < 3; i++) {
+            if (iShape.contains(piece)) {
+                pegsIndex[i] = getIShapePegsForPiecePlacement(origin, orient, i);
+            } else if (oShape.contains(piece)) {
+                pegsIndex[i] = getOShapePegsForPiecePlacement(origin, orient, i);
+            } else if (aShape.contains(piece)) {
+                pegsIndex[i] = getAShapePegsForPiecePlacement(origin, orient, i);
+            }
+        }
+
+        return pegsIndex;
+    }
+
+    /**
+     * By Hongbo
+     * return the pegs that the given unit in a give piece placement touches: I shape
+     * @param origin: the origin of the piece
+     * @param orient: the orientation of the piece
+     * @param index:  the index of the concerned unit.
+     * @return 1 ... 24, or -1 for the case if there is any unit in a piece is out of pegs
+     */
+    static int getIShapePegsForPiecePlacement(char origin, char orient, int index) {
+        // left and right edge
+        if (origin == 'A') {
+            if (orient == 'A' || orient == 'G' || orient == 'B' || orient == 'H') {
+                if (index == 0) return -1;
+            } else if (orient == 'D' || orient == 'J' || orient == 'E' || orient == 'K') {
+                if (index == 2) return -1;
+            } else if (orient == 'C' || orient == 'I' || orient == 'F' || orient == 'L') {
+                if (index == 0 || index == 2) return -1;
+            }
+        }
+        if (origin == 'S') {
+            if (orient == 'A' || orient == 'G' || orient == 'F' || orient == 'L' || orient == 'E' || orient == 'K') {
+                if (index == 0) return -1;
+            } else {
+                if (index == 2) return -1;
+            }
+        }
+        if (origin == 'F') {
+            if (orient == 'C' || orient == 'I' || orient == 'D' || orient == 'J' || orient == 'B' || orient == 'H') {
+                if (index == 0) return -1;
+            } else if (orient == 'A' || orient == 'G' || orient == 'F' || orient == 'L' || orient == 'E' || orient == 'K') {
+                if (index == 2) return -1;
+            }
+        }
+        if (origin == 'X') {
+            if (orient == 'D' || orient == 'J' || orient == 'E' || orient == 'K') {
+                if (index == 0) return -1;
+            } else if (orient == 'A' || orient == 'G' || orient == 'B' || orient == 'H') {
+                if (index == 2) return -1;
+            } else if (orient == 'C' || orient == 'I' || orient == 'F' || orient == 'L') {
+                if (index == 0 || index == 2) return -1;
+            }
+        }
+        if (origin == 'G') {
+            if (orient == 'A' || orient == 'G') {
+                if (index == 0) return -1;
+            } else if (orient == 'D' || orient == 'J') {
+                if (index == 2) return -1;
+            }
+        }
+        if (origin == 'R') {
+            if (orient == 'A' || orient == 'G') {
+                if (index == 2) return -1;
+            } else if (orient == 'D' || orient == 'J') {
+                if (index == 0) return -1;
+            }
+        }
+        if (origin == 'M') {
+            if (orient == 'A' || orient == 'G' || orient == 'F' || orient == 'L' || orient == 'B' || orient == 'H') {
+                if (index == 0) return -1;
+            } else if (orient == 'C' || orient == 'I' || orient == 'D' || orient == 'J' || orient == 'E' || orient == 'K') {
+                if (index == 2) return -1;
+            }
+        }
+        if (origin == 'L') {
+            if (orient == 'A' || orient == 'G' || orient == 'F' || orient == 'L' || orient == 'B' || orient == 'H') {
+                if (index == 2) return -1;
+            } else if (orient == 'C' || orient == 'I' || orient == 'D' || orient == 'J' || orient == 'E' || orient == 'K') {
+                if (index == 0) return -1;
+            }
+        }
+        /*if ( origin=='A'||origin=='G'||origin=='M'||origin=='S'||origin=='F'||origin=='L'||origin=='R'||origin=='X') {
+            return -1;
+        }*/
+        // first and last row
+        if (origin >= 'B' && origin <= 'E') {
+            if (orient == 'B' || orient == 'H' || orient == 'C' || orient == 'I') {
+                if (index == 0) return -1;
+            } else if (orient == 'F' || orient == 'L' || orient == 'E' || orient == 'K') {
+                if (index == 2) return -1;
+            }
+        }
+        if (origin >= 'T' && origin <= 'W') {
+            if (orient == 'B' || orient == 'H' || orient == 'C' || orient == 'I') {
+                if (index == 2) return -1;
+            } else if (orient == 'F' || orient == 'L' || orient == 'E' || orient == 'K') {
+                if (index == 0) return -1;
+            }
+        }
+        /*if ( ((origin>='B'&&origin<='E')||(origin>='T'&&origin<='W')) && ((orient!='A')&&(orient!='G')) ) {
+            return -1;
+        }*/
+        // other situations
+        if (orient == 'A' || orient == 'G') {
+            return ((char) ((int) origin + (index - 1))) - 'A';
+        } else if (orient == 'B' || orient == 'H') {
+            if ((origin >= 'G' && origin <= 'L') || (origin >= 'S' && origin <= 'X')) {
+                if (index == 0 || index == 1) {
+                    return ((char) ((int) origin + (index - 1) * 6)) - 'A';
+                } else {
+                    return ((char) ((int) origin + (index - 1) * 6 + 1)) - 'A';
+                }
+            } else if (origin >= 'M' && origin <= 'R' || (origin >= 'A' && origin <= 'F')) {
+                if (index == 0) {
+                    return ((char) ((int) origin + (index - 1) * 6 - 1)) - 'A';
+                } else {
+                    return ((char) ((int) origin + (index - 1) * 6)) - 'A';
+                }
+            }
+        } else if (orient == 'C' || orient == 'I') {
+            if (origin >= 'G' && origin <= 'L' || (origin >= 'S' && origin <= 'X')) {
+                if (index == 0) {
+                    return ((char) ((int) origin + (index - 1) * 6 + 1)) - 'A';
+                } else {
+                    return ((char) ((int) origin + (index - 1) * 6)) - 'A';
+                }
+            } else if (origin >= 'M' && origin <= 'R' || (origin >= 'A' && origin <= 'F')) {
+                if (index == 0 || index == 1) {
+                    return ((char) ((int) origin + (index - 1) * 6)) - 'A';
+                } else {
+                    return ((char) ((int) origin + (index - 1) * 6 - 1)) - 'A';
+                }
+            }
+        } else if (orient == 'D' || orient == 'J') {
+            return ((char) ((int) origin - (index - 1))) - 'A';
+        } else if (orient == 'E' || orient == 'K') {
+            if (origin >= 'G' && origin <= 'L' || (origin >= 'S' && origin <= 'X')) {
+                if (index == 2 || index == 1) {
+                    return ((char) ((int) origin - (index - 1) * 6)) - 'A';
+                } else {
+                    return ((char) ((int) origin - (index - 1) * 6 + 1)) - 'A';
+                }
+            } else if (origin >= 'M' && origin <= 'R' || (origin >= 'A' && origin <= 'F')) {
+                if (index == 2) {
+                    return ((char) ((int) origin - (index - 1) * 6 - 1)) - 'A';
+                } else {
+                    return ((char) ((int) origin - (index - 1) * 6)) - 'A';
+                }
+            }
+        } else if (orient == 'F' || orient == 'L') {
+            if (origin >= 'G' && origin <= 'L' || (origin >= 'S' && origin <= 'X')) {
+                if (index == 2) {
+                    return ((char) ((int) origin - (index - 1) * 6 + 1)) - 'A';
+                } else {
+                    return ((char) ((int) origin - (index - 1) * 6)) - 'A';
+                }
+            } else if (origin >= 'M' && origin <= 'R' || (origin >= 'A' && origin <= 'F')) {
+                if (index == 2 || index == 1) {
+                    return ((char) ((int) origin - (index - 1) * 6)) - 'A';
+                } else {
+                    return ((char) ((int) origin - (index - 1) * 6 - 1)) - 'A';
+                }
+            }
+        }
+        return -1;
     }
 
+    /**
+     * By Hongbo
+     * return the pegs that the given unit in a give piece placement touches: octuse angle
+     * @param origin: the origin of the piece
+     * @param orient: the orientation of the piece
+     * @param index:  the index of the concerned unit.
+     * @return 1 ... 24, or -1 for the case if there is any unit in a piece is out of pegs
+     */
+    static int getOShapePegsForPiecePlacement(char origin, char orient, int index) {
+        // boundary case
+        // left and right edge
+        if (origin == 'A') {
+            if (orient == 'B' || orient == 'C' || orient == 'G' || orient == 'L') {
+                if (index == 0) return -1;
+            } else if (orient == 'D' || orient == 'E' || orient == 'J' || orient == 'K') {
+                if (index == 2) return -1;
+            } else if (orient == 'A' || orient == 'F' || orient == 'H' || orient == 'I') {
+                if (index == 0 || index == 2) return -1;
+            }
+        }
+        if (origin == 'S') {
+            if (orient == 'A' || orient == 'F' || orient == 'K' || orient == 'L') {
+                if (index == 0) return -1;
+            } else if (orient == 'C' || orient == 'D' || orient == 'H' || orient == 'I') {
+                if (index == 2) return -1;
+            } else if (orient == 'E' || orient == 'G') {
+                if (index == 0 || index == 2) return -1;
+            }
+        }
+        if (origin == 'F') {
+            if (orient == 'C' || orient == 'D' || orient == 'H' || orient == 'I') {
+                if (index == 0) return -1;
+            } else if (orient == 'A' || orient == 'F' || orient == 'K' || orient == 'L') {
+                if (index == 2) return -1;
+            } else if (orient == 'B' || orient == 'J') {
+                if (index == 0 || index == 2) return -1;
+            }
+        }
+        if (origin == 'X') {
+            if (orient == 'E' || orient == 'F' || orient == 'I' || orient == 'J') {
+                if (index == 0) return -1;
+            } else if (orient == 'A' || orient == 'B' || orient == 'G' || orient == 'H') {
+                if (index == 2) return -1;
+            } else if (orient == 'C' || orient == 'D' || orient == 'K' || orient == 'L') {
+                if (index == 0 || index == 2) return -1;
+            }
+        }
+        if (origin == 'G') {
+            if (orient == 'A' || orient == 'G') {
+                if (index == 0) return -1;
+            } else if (orient == 'E' || orient == 'I') {
+                if (index == 2) return -1;
+            }
+        }
+        if (origin == 'R') {
+            if (orient == 'B' || orient == 'L') {
+                if (index == 2) return -1;
+            } else if (orient == 'D' || orient == 'J') {
+                if (index == 0) return -1;
+            }
+        }
+        if (origin == 'M') {
+            if (orient == 'A' || orient == 'B' || orient == 'G' || orient == 'L') {
+                if (index == 0) return -1;
+            } else if (orient == 'D' || orient == 'E' || orient == 'I' || orient == 'J') {
+                if (index == 2) return -1;
+            } else if (orient == 'F' || orient == 'H') {
+                if (index == 0 || index == 2) return -1;
+            }
+        }
+        if (origin == 'L') {
+            if (orient == 'A' || orient == 'B' || orient == 'G' || orient == 'L') {
+                if (index == 2) return -1;
+            } else if (orient == 'D' || orient == 'E' || orient == 'I' || orient == 'J') {
+                if (index == 0) return -1;
+            } else if (orient == 'C' || orient == 'K') {
+                if (index == 0 || index == 2) return -1;
+            }
+        }
+        // first and last row
+        if (origin >= 'B' && origin <= 'E') {
+            if (orient == 'B' || orient == 'H' || orient == 'C' || orient == 'I') {
+                if (index == 0) return -1;
+            } else if (orient == 'A' || orient == 'F' || orient == 'J' || orient == 'K') {
+                if (index == 2) return -1;
+            }
+        }
+        if (origin >= 'T' && origin <= 'W') {
+            if (orient == 'C' || orient == 'D' || orient == 'G' || orient == 'H') {
+                if (index == 2) return -1;
+            } else if (orient == 'E' || orient == 'F' || orient == 'K' || orient == 'L') {
+                if (index == 0) return -1;
+            }
+        }
+        // second row and last row
+        if (origin >= 'G' && origin <= 'L' || (origin >= 'S' && origin <= 'X')) {
+            if (orient == 'A') {
+                if (index == 0) {
+                    return ((char) ((int) origin - 1)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin - 5)) - 'A';
+                }
+            } else if (orient == 'B') {
+                if (index == 0) {
+                    return ((char) ((int) origin - 6)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin + 1)) - 'A';
+                }
+            } else if (orient == 'C') {
+                if (index == 0) {
+                    return ((char) ((int) origin - 5)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin + 7)) - 'A';
+                }
+            } else if (orient == 'D') {
+                if (index == 0) {
+                    return ((char) ((int) origin + 1)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin + 6)) - 'A';
+                }
+            } else if (orient == 'E') {
+                if (index == 0) {
+                    return ((char) ((int) origin + 7)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin - 1)) - 'A';
+                }
+            } else if (orient == 'F') {
+                if (index == 0) {
+                    return ((char) ((int) origin + 6)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin - 6)) - 'A';
+                }
+            } else if (orient == 'G') {
+                if (index == 0) {
+                    return ((char) ((int) origin - 1)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin + 7)) - 'A';
+                }
+            } else if (orient == 'H') {
+                if (index == 0) {
+                    return ((char) ((int) origin - 6)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin + 6)) - 'A';
+                }
+            } else if (orient == 'I') {
+                if (index == 0) {
+                    return ((char) ((int) origin - 5)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin - 1)) - 'A';
+                }
+            } else if (orient == 'J') {
+                if (index == 0) {
+                    return ((char) ((int) origin + 1)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin - 6)) - 'A';
+                }
+            } else if (orient == 'K') {
+                if (index == 0) {
+                    return ((char) ((int) origin + 7)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin - 5)) - 'A';
+                }
+            } else if (orient == 'L') {
+                if (index == 0) {
+                    return ((char) ((int) origin + 6)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin + 1)) - 'A';
+                }
+            }
+        }
+        // third row and first row
+        if (origin >= 'M' && origin <= 'R' || (origin >= 'A' && origin <= 'F')) {
+            if (orient == 'A') {
+                if (index == 0) {
+                    return ((char) ((int) origin - 1)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin - 6)) - 'A';
+                }
+            } else if (orient == 'B') {
+                if (index == 0) {
+                    return ((char) ((int) origin - 7)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin + 1)) - 'A';
+                }
+            } else if (orient == 'C') {
+                if (index == 0) {
+                    return ((char) ((int) origin - 6)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin + 6)) - 'A';
+                }
+            } else if (orient == 'D') {
+                if (index == 0) {
+                    return ((char) ((int) origin + 1)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin + 5)) - 'A';
+                }
+            } else if (orient == 'E') {
+                if (index == 0) {
+                    return ((char) ((int) origin + 6)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin - 1)) - 'A';
+                }
+            } else if (orient == 'F') {
+                if (index == 0) {
+                    return ((char) ((int) origin + 5)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin - 7)) - 'A';
+                }
+            } else if (orient == 'G') {
+                if (index == 0) {
+                    return ((char) ((int) origin - 1)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin + 6)) - 'A';
+                }
+            } else if (orient == 'H') {
+                if (index == 0) {
+                    return ((char) ((int) origin - 7)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin + 5)) - 'A';
+                }
+            } else if (orient == 'I') {
+                if (index == 0) {
+                    return ((char) ((int) origin - 6)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin - 1)) - 'A';
+                }
+            } else if (orient == 'J') {
+                if (index == 0) {
+                    return ((char) ((int) origin + 1)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin - 7)) - 'A';
+                }
+            } else if (orient == 'K') {
+                if (index == 0) {
+                    return ((char) ((int) origin + 6)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin - 6)) - 'A';
+                }
+            } else if (orient == 'L') {
+                if (index == 0) {
+                    return ((char) ((int) origin + 5)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin + 1)) - 'A';
+                }
+            }
+        }
+        return -1;
+    }
 
     /**
+     * By Hongbo
+     * return the pegs that the given unit in a give piece placement touches: acute angle
+     * @param origin: the origin of the piece
+     * @param orient: the orientation of the piece
+     * @param index:  the index of the concerned unit.
+     * @return 1 ... 24, or -1 for the case if there is any unit in a piece is out of pegs
+     */
+    static int getAShapePegsForPiecePlacement(char origin, char orient, int index) {
+        //boundary case
+        /*if ( origin == 'A' && ( orient != 'D' && orient != 'K' )) return -1;
+        if ( origin == 'F' && ( orient != 'F' && orient != 'G' )) return -1;
+        if ( origin == 'S' && ( orient != 'B' && orient != 'C' && orient != 'I' && orient != 'J' )) return -1;
+        if ( origin == 'X' && ( orient != 'A' && orient != 'H' )) return -1;
+        if ( origin == 'G' && ( orient == 'A' || orient == 'F' || orient == 'G' || orient == 'H' )) return -1;
+        if ( origin == 'M' && ( orient != 'C' && orient != 'D' && orient != 'J' && orient != 'K' )) return -1;
+        if ( origin == 'L' && ( orient != 'A' && orient != 'F' && orient != 'G' && orient != 'H' )) return -1;
+        if ( origin == 'R' && ( orient == 'C' || orient == 'D' || orient == 'J' || orient == 'K' )) return -1;
+        if ( origin>'A' && origin<'F' && (orient=='A'||orient=='B'||orient=='C'||orient=='H'||orient=='I'||orient=='J')) return -1;
+        if ( origin>'S' && origin<'X' && (orient=='D'||orient=='E'||orient=='F'||orient=='G'||orient=='K'||orient=='L')) return -1;*/
+        // left and right edge
+        if (origin == 'A') {
+            if (orient == 'C' || orient == 'L') {
+                if (index == 0) return -1;
+            } else if (orient == 'E' || orient == 'J') {
+                if (index == 2) return -1;
+            } else if (orient == 'A' || orient == 'B' || orient == 'F' || orient == 'G' || orient == 'H' || orient == 'I') {
+                if (index == 0 || index == 2) return -1;
+            }
+        }
+        if (origin == 'S') {
+            if (orient == 'A' || orient == 'K') {
+                if (index == 0) return -1;
+            } else if (orient == 'D' || orient == 'H') {
+                if (index == 2) return -1;
+            } else if (orient == 'E' || orient == 'F' || orient == 'G' || orient == 'L') {
+                if (index == 0 || index == 2) return -1;
+            }
+        }
+        if (origin == 'F') {
+            if (orient == 'H' || orient == 'D') {
+                if (index == 0) return -1;
+            } else if (orient == 'A' || orient == 'K') {
+                if (index == 2) return -1;
+            } else if (orient == 'B' || orient == 'C' || orient == 'I' || orient == 'J') {
+                if (index == 0 || index == 2) return -1;
+            }
+        }
+        if (origin == 'X') {
+            if (orient == 'F' || orient == 'I') {
+                if (index == 0) return -1;
+            } else if (orient == 'B' || orient == 'G') {
+                if (index == 2) return -1;
+            } else if (orient == 'C' || orient == 'D' || orient == 'E' || orient == 'J' || orient == 'K' || orient == 'L') {
+                if (index == 0 || index == 2) return -1;
+            }
+        }
+        if (origin == 'G') {
+            if (orient == 'A' || orient == 'G') {
+                if (index == 0) return -1;
+            } else if (orient == 'F' || orient == 'H') {
+                if (index == 2) return -1;
+            }
+        }
+        if (origin == 'R') {
+            if (orient == 'C' || orient == 'K') {
+                if (index == 2) return -1;
+            } else if (orient == 'D' || orient == 'J') {
+                if (index == 0) return -1;
+            }
+        }
+        if (origin == 'M') {
+            if (orient == 'B' || orient == 'L') {
+                if (index == 0) return -1;
+            } else if (orient == 'E' || orient == 'I') {
+                if (index == 2) return -1;
+            } else if (orient == 'A' || orient == 'F' || orient == 'G' || orient == 'H') {
+                if (index == 0 || index == 2) return -1;
+            }
+        }
+        if (origin == 'L') {
+            if (orient == 'B' || orient == 'L') {
+                if (index == 2) return -1;
+            } else if (orient == 'E' || orient == 'I') {
+                if (index == 0) return -1;
+            } else if (orient == 'C' || orient == 'J' || orient == 'D' || orient == 'K') {
+                if (index == 0 || index == 2) return -1;
+            }
+        }
+        // first and last row
+        if (origin >= 'B' && origin <= 'E') {
+            if (orient == 'H' || orient == 'C') {
+                if (index == 0) return -1;
+            } else if (orient == 'A' || orient == 'J') {
+                if (index == 2) return -1;
+            } else if (orient == 'B' || orient == 'I') {
+                if (index == 0 || index == 2) return -1;
+            }
+        }
+        if (origin >= 'T' && origin <= 'W') {
+            if (orient == 'D' || orient == 'G') {
+                if (index == 2) return -1;
+            } else if (orient == 'F' || orient == 'K') {
+                if (index == 0) return -1;
+            } else if (orient == 'E' || orient == 'L') {
+                if (index == 0 || index == 2) return -1;
+            }
+        }
+        // first and third row
+        if ((origin >= 'A' && origin <= 'F') || (origin >= 'M' && origin <= 'R')) {
+            if (orient == 'A') {
+                if (index == 0) {
+                    return ((char) ((int) origin - 1)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin - 7)) - 'A';
+                }
+            } else if (orient == 'B') {
+                if (index == 0) {
+                    return ((char) ((int) origin - 7)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin - 6)) - 'A';
+                }
+            } else if (orient == 'C') {
+                if (index == 0) {
+                    return ((char) ((int) origin - 6)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin + 1)) - 'A';
+                }
+            } else if (orient == 'D') {
+                if (index == 0) {
+                    return ((char) ((int) origin + 1)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin + 6)) - 'A';
+                }
+            } else if (orient == 'E') {
+                if (index == 0) {
+                    return ((char) ((int) origin + 6)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin + 5)) - 'A';
+                }
+            } else if (orient == 'F') {
+                if (index == 0) {
+                    return ((char) ((int) origin + 5)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin - 1)) - 'A';
+                }
+            } else if (orient == 'G') {
+                if (index == 0) {
+                    return ((char) ((int) origin - 1)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin + 5)) - 'A';
+                }
+            } else if (orient == 'H') {
+                if (index == 0) {
+                    return ((char) ((int) origin - 7)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin - 1)) - 'A';
+                }
+            } else if (orient == 'I') {
+                if (index == 0) {
+                    return ((char) ((int) origin - 6)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin - 7)) - 'A';
+                }
+            } else if (orient == 'J') {
+                if (index == 0) {
+                    return ((char) ((int) origin + 1)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin - 6)) - 'A';
+                }
+            } else if (orient == 'K') {
+                if (index == 0) {
+                    return ((char) ((int) origin + 6)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin + 1)) - 'A';
+                }
+            } else if (orient == 'L') {
+                if (index == 0) {
+                    return ((char) ((int) origin + 5)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin + 6)) - 'A';
+                }
+            }
+        }
+        // second and last row
+        if ((origin >= 'G' && origin <= 'L') || (origin >= 'S' && origin <= 'X')) {
+            if (orient == 'A') {
+                if (index == 0) {
+                    return ((char) ((int) origin - 1)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin - 6)) - 'A';
+                }
+            } else if (orient == 'B') {
+                if (index == 0) {
+                    return ((char) ((int) origin - 6)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin - 5)) - 'A';
+                }
+            } else if (orient == 'C') {
+                if (index == 0) {
+                    return ((char) ((int) origin - 5)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin + 1)) - 'A';
+                }
+            } else if (orient == 'D') {
+                if (index == 0) {
+                    return ((char) ((int) origin + 1)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin + 7)) - 'A';
+                }
+            } else if (orient == 'E') {
+                if (index == 0) {
+                    return ((char) ((int) origin + 7)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin + 6)) - 'A';
+                }
+            } else if (orient == 'F') {
+                if (index == 0) {
+                    return ((char) ((int) origin + 6)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin - 1)) - 'A';
+                }
+            } else if (orient == 'G') {
+                if (index == 0) {
+                    return ((char) ((int) origin - 1)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin + 6)) - 'A';
+                }
+            } else if (orient == 'H') {
+                if (index == 0) {
+                    return ((char) ((int) origin - 6)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin - 1)) - 'A';
+                }
+            } else if (orient == 'I') {
+                if (index == 0) {
+                    return ((char) ((int) origin - 5)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin - 6)) - 'A';
+                }
+            } else if (orient == 'J') {
+                if (index == 0) {
+                    return ((char) ((int) origin + 1)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin - 5)) - 'A';
+                }
+            } else if (orient == 'K') {
+                if (index == 0) {
+                    return ((char) ((int) origin + 7)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin + 1)) - 'A';
+                }
+            } else if (orient == 'L') {
+                if (index == 0) {
+                    return ((char) ((int) origin + 6)) - 'A';
+                } else if (index == 1) {
+                    return origin - 'A';
+                } else {
+                    return ((char) ((int) origin + 7)) - 'A';
+                }
+            }
+        }
+        return -1;
+    }
+
+    /**
+     * By Hongbo
+     * @param placement: the placement array, such as BAAHBATCJRDKWEBEFDNGLPHEDIFMJJQKIKLJ
+     * @return: a string array, each element is a pieceplacement string. such asS BAA,HBA,TCJ,RDK,WEB,EFD,NGL,PHE,DIF,MJJ,QKI,KLJ
+     */
+    static String[] toPlacementStringArray(String placement) {
+        String[] piecePlaceArray = new String[placement.length() / 3];
+        if (isPlacementWellFormed(placement)) {
+            for (int i = 0; i < placement.length() / 3; i++) {
+                piecePlaceArray[i] = placement.substring(3 * i, 3 * i + 3);
+            }
+        }
+        return piecePlaceArray;
+    }
+
+    /**
+     * By Hongbo
+     * not used any more
+     * TODO upgrade the algorithm: record the last one, use iteration, and only check the pegs of new placing piece
      * Determine whether a placement is valid.  To be valid, the placement must be well-formed
      * and each piece must correctly connect with each other.
-     *
      * @param placement A placement string
      * @return True if the placement is valid
-     */
-    static boolean isPlacementValid(String placement) {
+    */
+    public static boolean isPlacementValidOld(String placement) {
         // FIXME Task 7: determine whether a placement is valid
+
+        //placement = "KAFCBGUCAGDFLEFPFBBGESHBWIJKJAHKLJLH";
+        //placement = "BAAHBATCJRDKWEBEFDNGLPHEDIFMJJQKIKLJ";
+        occupationArray.clear();
+        if (!isPlacementWellFormed(placement)) return false;
+
+        if ( outOfPeg(placement) ) return false;
+
+        setOccupationArray(placement);
+
+        //System.out.println(occupationArray);
+
+        return checkOccupationArray();
+    }
+
+    /**
+     * By Hongbo
+     * use iteration method
+     * Determine whether a placement is valid.  To be valid, the placement must be well-formed
+     * and each piece must correctly connect with each other.
+     * @param placement A placement string
+     * @return True if the placement is valid
+     */
+    public static boolean isPlacementValid(String placement) {
+        int len = placement.length();
+        if ( len > 3 ) {
+            if ( isPlacementValid(placement.substring(0,len-3)) ) {
+                return isPlacementValid(placement.substring(0, len - 3), placement.substring(len - 3, len));
+            }
+        } else {
+            if (!isPlacementWellFormed(placement)) return false;
+            occupationArray.clear();
+            if ( outOfPegSinglePiece(placement) ) return false;
+            setOccupationArray("",placement);
+            return checkOccupationArraySinglePiece();
+        }
         return false;
     }
 
     /**
-     * Return an array of all solutions given a starting placement.
+     * By Hongbo
+     * TODO upgrade the algorithm: record the last one, use iteration, and only check the pegs of new placing piece
+     * check whether any unit of pieces in placement is out of peg or not
+     * @param placement placement String
+     * @return true if some unit is out of peg, false if none unit is out of peg
+     */
+    private static boolean outOfPeg(String placement) {
+        String[] piecePlaceArray = toPlacementStringArray(placement);
+        for (int i = 0; i < piecePlaceArray.length; i++) {
+            int[] pegOccupied = getPegsForPiecePlacement(piecePlaceArray[i]);
+            for (int j = 0; j < 3; j++) {
+                if (pegOccupied[j] == -1) return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * By Hongbo
+     * TODO upgrade the algorithm: record the last one, use iteration, and only check the pegs of new placing piece
+     * @param placement set occupationArray, which record the occupation status of each peg
+     */
+    private static void setOccupationArray(String placement) {
+        // set occupationArray which record which pegs are occupied by which units.
+        String[] piecePlaceArray = toPlacementStringArray(placement);
+        //String[] piecePlaceArray = toPlacementStringArray("BAAHBATCJRDKWEBEFDNGLPHEDIFMJJQKIKLJ");
+        for (int i = 0; i < piecePlaceArray.length; i++) {
+            String currentPiecePlacementString = piecePlaceArray[i];
+            int[] pegOccupied = getPegsForPiecePlacement(currentPiecePlacementString);
+            //System.out.println(pegOccupied[0] + " " + pegOccupied[1] + " " + pegOccupied[2]);
+            PiecePlacement currentPiecePlacement = new PiecePlacement(currentPiecePlacementString);
+
+            //System.out.println("currentPiecePlacementString"+currentPiecePlacementString);
+            //System.out.println(currentPiecePlacement.piece);
+            //System.out.println(currentPiecePlacement.piece.uandos[2]);
+
+            currentPiecePlacement.translateorientation(currentPiecePlacement.piece, currentPiecePlacement.ori);
+
+            for (int j = 0; j < 3; j++) {
+                //if (pegOccupied[j] == -1) return false;
+                if (!occupationArray.containsKey(pegOccupied[j])) {
+                    //ArrayList<UandO> newUandOArray = new ArrayList<>();
+                    ArrayList<String> newUandOArray = new ArrayList<>();
+                    newUandOArray.add(currentPiecePlacement.piece.uandos[j].toString());
+                    occupationArray.put(pegOccupied[j], newUandOArray);
+                    //System.out.println(pegOccupied[j] +" "+ occupationArray.get(pegOccupied[j]));
+                } else {
+                    //System.out.println(pegOccupied[j] +" "+ occupationArray.get(pegOccupied[j]));
+                    occupationArray.get(pegOccupied[j]).add(currentPiecePlacement.piece.uandos[j].toString());
+                    //System.out.println(pegOccupied[j] +" "+ occupationArray.get(pegOccupied[j]));
+                }
+            }
+        }
+    }
+
+    /**
+     * By Hongbo
+     * TODO upgrade the algorithm: record the last one, use iteration, and only check the pegs of new placing piece
+     * check the placement is valid through checking the occupation array
+     * a peg cannot place more than two units
+     * a peg cannot place two balls or two rings
+     * if a peg is placed with a ball and a ring, they must satisfy: ball1~ring1, bing2~ring2, bing1~ring2
+     * the ball and the ring on the same peg must match each other
+     * @return true if valid, false if invalid
+     */
+    private static boolean checkOccupationArray() {
+        for (Integer keys : occupationArray.keySet()) {
+
+            // test whether a peg is occupied by more than two units
+            if (occupationArray.get(keys).size() > 2) return false;
+
+            // test whether a peg is occupied by two balls or two rings
+            if (occupationArray.get(keys).size() == 2) {
+                //if ( occupationArray.get(keys).get(0).unit.type == occupationArray.get(keys).get(1).unit.type ) {
+                if (occupationArray.get(keys).get(0).charAt(0) == occupationArray.get(keys).get(1).charAt(0)) {
+                    return false;
+                }
+            }
+
+            /*// test whether a peg is occupied by a ball and a ring with the same opening
+            if ( occupationArray.get(keys).size() == 2 ) {
+                //if ( occupationArray.get(keys).get(0).unit.open != occupationArray.get(keys).get(1).unit.open ) {
+                if ( occupationArray.get(keys).get(0).charAt(1) != occupationArray.get(keys).get(1).charAt(1) ) {
+                    return false;
+                }
+            }*/
+
+            // test ball1~ring1, bing2~ring2, bing1~ring2
+            if (occupationArray.get(keys).size() == 2) {
+                if (occupationArray.get(keys).get(0).charAt(1) != occupationArray.get(keys).get(1).charAt(1)) {
+                    String first = occupationArray.get(keys).get(0).substring(0, 2);
+                    String second = occupationArray.get(keys).get(1).substring(0, 2);
+                    boolean condition1 = first.equals("B1") && second.equals("R2");
+                    boolean condition2 = first.equals("R2") && second.equals("B1");
+                    boolean condition = condition1 || condition2;
+                    if (!condition) {
+                        return false;
+                    }
+                }
+            }
+
+            // test whether a peg is occupied by ball1 and ring1 with matching direction
+            if (occupationArray.get(keys).size() == 2) {
+                if (occupationArray.get(keys).get(0).charAt(1) == occupationArray.get(keys).get(1).charAt(1)) {
+                    //if ( occupationArray.get(keys).get(0).orientation != occupationArray.get(keys).get(1).orientation ) {
+                    if (occupationArray.get(keys).get(0).charAt(2) != occupationArray.get(keys).get(1).charAt(2)) {
+                        return false;
+                    }
+                }
+            }
+
+            // test whether a peg is occupied by ball1 and ring2 with matching direction
+            if (occupationArray.get(keys).size() == 2) {
+                if (occupationArray.get(keys).get(0).charAt(1) != occupationArray.get(keys).get(1).charAt(1)) {
+                    String first = "";
+                    String second = "";
+                    if (occupationArray.get(keys).get(0).substring(0, 2).equals("B1") && occupationArray.get(keys).get(1).substring(0, 2).equals("R2")) {
+                        first = occupationArray.get(keys).get(0);
+                        second = occupationArray.get(keys).get(1);
+                    } else if (occupationArray.get(keys).get(0).substring(0, 2).equals("R2") && occupationArray.get(keys).get(1).substring(0, 2).equals("B1")) {
+                        first = occupationArray.get(keys).get(1);
+                        second = occupationArray.get(keys).get(0);
+                    } else {
+                        System.out.println("Error in matching between B1 and R2");
+                    }
+                    if (!isMatchBetweenB1AndR2(first.charAt(2), second.charAt(2))) {
+                        return false;
+                    }
+                }
+            }
+        }
+        return true;
+    }
+
+    /**
+     * By Hongbo
+     * check whether orietation of Ball 1 and Ring 2 matches with each other or not
+     * @param b1 the orientation of ball1
+     * @param r2 the orientation of ring2
+     * @return
+     */
+    private static boolean isMatchBetweenB1AndR2(char b1, char r2) {
+        boolean result = false;
+        boolean condition1 = ((r2 == 'A') && ((b1 == 'B') || (b1 == 'C')));
+        boolean condition2 = ((r2 == 'B') && ((b1 == 'C') || (b1 == 'D')));
+        boolean condition3 = ((r2 == 'C') && ((b1 == 'D') || (b1 == 'E')));
+        boolean condition4 = ((r2 == 'D') && ((b1 == 'E') || (b1 == 'F')));
+        boolean condition5 = ((r2 == 'E') && ((b1 == 'F') || (b1 == 'A')));
+        boolean condition6 = ((r2 == 'F') && ((b1 == 'A') || (b1 == 'B')));
+        result = condition1 || condition2 || condition3 || condition4 || condition5 || condition6;
+        return result;
+    }
+
+    /**
+     * By Hongbo
+     * "placement" is already a valid placement (but its length is less than 3*12),
+     * and then we add a piece placement "newPiece" to placement.
+     * check whether the "placement"+"newPiece" is valid or not
+     * @param placement it is already a valid placement (but its length is less than 3*12)
+     * @param newPiece the new piece placement "newPiece" to be added at the end of "placement"
+     * @return true: valid; false: invalid
+     */
+    public static boolean isPlacementValid(String placement, String newPiece) {
+        callIsPlacementValid++;
+        if ( placement.equals("") && newPiece.equals("")) return true;
+        if (!isPlacementWellFormed(placement+newPiece)) return false;
+        if ( placement.length() == 0 ) occupationArray.clear();
+        if ( outOfPegSinglePiece(newPiece) ) return false;
+        setOccupationArray(placement, newPiece);
+        return checkOccupationArraySinglePiece();
+    }
+
+    /**
+     * By Hongbo
+     * check whether the given piece is out of peg or not
+     * @param newPiece single piece placement String
+     * @return true if some unit is out of peg, false if none unit is out of peg
+     */
+    private static boolean outOfPegSinglePiece(String newPiece) {
+        pegIndex = getPegsForPiecePlacement(newPiece);
+        for (int j = 0; j < 3; j++) {
+            if (pegIndex[j] == -1) return true;
+        }
+        return false;
+    }
+
+    /**
+     * By Hongbo
+     * we already set the occupationArray based on "placement",
+     * and then we add a new piece placement "newPiece" to the "placement".
+     * in this case, occupationArray is to be updated by this method
+     * @param placement it is already a valid placement (but its length is less than 36)
+     * @param newPiece the new piece placement "newPiece" to be added at the end of "placement"
+     */
+    private  static void setOccupationArray(String placement, String newPiece) {
+        PiecePlacement newPiecePlacement = new PiecePlacement(newPiece);
+        newPiecePlacement.translateorientation(newPiecePlacement.piece, newPiecePlacement.ori);
+        for (int j = 0; j < 3; j++) {
+            if (!occupationArray.containsKey(pegIndex[j])) {
+                ArrayList<String> newUandOArray = new ArrayList<>();
+                newUandOArray.add(newPiecePlacement.piece.uandos[j].toString());
+                occupationArray.put(pegIndex[j], newUandOArray);
+            } else {
+                occupationArray.get(pegIndex[j]).add(newPiecePlacement.piece.uandos[j].toString());
+            }
+        }
+    }
+
+    /**
+     * By Hongbo
+     * only check the new added piece placement is valid or not.
+     * only check the pegIndex, which record the pegs occupied by the last piece placement in occupationArray.
+     * a peg cannot place more than two units
+     * a peg cannot place two balls or two rings
+     * if a peg is placed with a ball and a ring, they must satisfy: ball1~ring1, bing2~ring2, bing1~ring2
+     * the ball and the ring on the same peg must match each other
+     * @return true if valid, false if invalid
+     */
+    private static boolean checkOccupationArraySinglePiece() {
+        for (int i = 0; i < 3; i++) {
+
+            Integer keys = pegIndex[i];
+
+            // test whether a peg is occupied by more than two units
+            if (occupationArray.get(keys).size() > 2) return false;
+
+            // test whether a peg is occupied by two balls or two rings
+            if (occupationArray.get(keys).size() == 2) {
+                //if ( occupationArray.get(keys).get(0).unit.type == occupationArray.get(keys).get(1).unit.type ) {
+                if (occupationArray.get(keys).get(0).charAt(0) == occupationArray.get(keys).get(1).charAt(0)) {
+                    return false;
+                }
+            }
+
+            // test ball1~ring1, bing2~ring2, bing1~ring2
+            if (occupationArray.get(keys).size() == 2) {
+                if (occupationArray.get(keys).get(0).charAt(1) != occupationArray.get(keys).get(1).charAt(1)) {
+                    String first = occupationArray.get(keys).get(0).substring(0, 2);
+                    String second = occupationArray.get(keys).get(1).substring(0, 2);
+                    boolean condition1 = first.equals("B1") && second.equals("R2");
+                    boolean condition2 = first.equals("R2") && second.equals("B1");
+                    boolean condition = condition1 || condition2;
+                    if (!condition) {
+                        return false;
+                    }
+                }
+            }
+
+            // test whether a peg is occupied by ball1 and ring1 with matching direction
+            if (occupationArray.get(keys).size() == 2) {
+                if (occupationArray.get(keys).get(0).charAt(1) == occupationArray.get(keys).get(1).charAt(1)) {
+                    //if ( occupationArray.get(keys).get(0).orientation != occupationArray.get(keys).get(1).orientation ) {
+                    if (occupationArray.get(keys).get(0).charAt(2) != occupationArray.get(keys).get(1).charAt(2)) {
+                        return false;
+                    }
+                }
+            }
+
+            // test whether a peg is occupied by ball1 and ring2 with matching direction
+            if (occupationArray.get(keys).size() == 2) {
+                if (occupationArray.get(keys).get(0).charAt(1) != occupationArray.get(keys).get(1).charAt(1)) {
+                    String first = "";
+                    String second = "";
+                    if (occupationArray.get(keys).get(0).substring(0, 2).equals("B1") && occupationArray.get(keys).get(1).substring(0, 2).equals("R2")) {
+                        first = occupationArray.get(keys).get(0);
+                        second = occupationArray.get(keys).get(1);
+                    } else if (occupationArray.get(keys).get(0).substring(0, 2).equals("R2") && occupationArray.get(keys).get(1).substring(0, 2).equals("B1")) {
+                        first = occupationArray.get(keys).get(1);
+                        second = occupationArray.get(keys).get(0);
+                    } else {
+                        System.out.println("Error in matching between B1 and R2");
+                    }
+                    if (!isMatchBetweenB1AndR2(first.charAt(2), second.charAt(2))) {
+                        return false;
+                    }
+                }
+            }
+        }
+        return true;
+    }
+
+    /**
+     * By Hongbo
+     * "placement" is already a valid placement (but its length is less than 3*12),
+     * and then we add a piece placement "newPiece" to placement.
+     * check whether the "placement"+"newPiece" is valid or not
+     * does not use the static occupationArray. occupy records the peg occupied status of String placement.
+     * @param placement it is already a valid placement (but its length is less than 3*12)
+     * @param newPiece the new piece placement "newPiece" to be added at the end of "placement"
+     * @return true: valid; false: invalid
+     */
+    public static boolean isPlacementValid(String placement, String newPiece, HashMap<Integer, ArrayList<String>> occupy) {
+        if (!isPlacementWellFormed(placement+newPiece)) return false;
+        if ( outOfPegSinglePiece(newPiece) ) return false;
+        setOccupationArray(placement, newPiece, occupy);
+        return checkOccupationArraySinglePiece(occupy);
+    }
+
+
+    /**
+     * By Hongbo
+     * we already set the occupy based on "placement",
+     * and then we add a new piece placement "newPiece" to the "placement".
+     * in this case, occupy is to be updated by this method
+     * does not use the static occupationArray.
+     * occupy records the peg occupied status of String placement. it will be update to record the peg occupied status of String "placement+newPiece" in this method
+     * @param placement it is already a valid placement (but its length is less than 36)
+     * @param newPiece the new piece placement "newPiece" to be added at the end of "placement"
+     */
+    private  static void setOccupationArray(String placement, String newPiece, HashMap<Integer, ArrayList<String>> occupy) {
+        PiecePlacement newPiecePlacement = new PiecePlacement(newPiece);
+        newPiecePlacement.translateorientation(newPiecePlacement.piece, newPiecePlacement.ori);
+        for (int j = 0; j < 3; j++) {
+            if (!occupy.containsKey(pegIndex[j])) {
+                ArrayList<String> newUandOArray = new ArrayList<>();
+                newUandOArray.add(newPiecePlacement.piece.uandos[j].toString());
+                occupy.put(pegIndex[j], newUandOArray);
+            } else {
+                occupy.get(pegIndex[j]).add(newPiecePlacement.piece.uandos[j].toString());
+            }
+        }
+    }
+
+    /**
+     * By Hongbo
+     * occupy records the peg occupied status of String placement.
+     * only check the new added piece placement is valid or not.
+     * only check the pegIndex, which record the pegs occupied by the last piece placement in occupy.
+     * a peg cannot place more than two units
+     * a peg cannot place two balls or two rings
+     * if a peg is placed with a ball and a ring, they must satisfy: ball1~ring1, bing2~ring2, bing1~ring2
+     * the ball and the ring on the same peg must match each other
+     * @return true if valid, false if invalid
+     */
+    private static boolean checkOccupationArraySinglePiece(HashMap<Integer, ArrayList<String>> occupy) {
+        for (int i = 0; i < 3; i++) {
+
+            Integer keys = pegIndex[i];
+
+            // test whether a peg is occupied by more than two units
+            if (occupy.get(keys).size() > 2) return false;
+
+            // test whether a peg is occupied by two balls or two rings
+            if (occupy.get(keys).size() == 2) {
+                if (occupy.get(keys).get(0).charAt(0) == occupy.get(keys).get(1).charAt(0)) {
+                    return false;
+                }
+            }
+
+            // test ball1~ring1, bing2~ring2, bing1~ring2
+            if (occupy.get(keys).size() == 2) {
+                if (occupy.get(keys).get(0).charAt(1) != occupy.get(keys).get(1).charAt(1)) {
+                    String first = occupy.get(keys).get(0).substring(0, 2);
+                    String second = occupy.get(keys).get(1).substring(0, 2);
+                    boolean condition1 = first.equals("B1") && second.equals("R2");
+                    boolean condition2 = first.equals("R2") && second.equals("B1");
+                    boolean condition = condition1 || condition2;
+                    if (!condition) {
+                        return false;
+                    }
+                }
+            }
+
+            // test whether a peg is occupied by ball1 and ring1 with matching direction
+            if (occupy.get(keys).size() == 2) {
+                if (occupy.get(keys).get(0).charAt(1) == occupy.get(keys).get(1).charAt(1)) {
+                    if (occupy.get(keys).get(0).charAt(2) != occupy.get(keys).get(1).charAt(2)) {
+                        return false;
+                    }
+                }
+            }
+
+            // test whether a peg is occupied by ball1 and ring2 with matching direction
+            if (occupy.get(keys).size() == 2) {
+                if (occupy.get(keys).get(0).charAt(1) != occupy.get(keys).get(1).charAt(1)) {
+                    String first = "";
+                    String second = "";
+                    if (occupy.get(keys).get(0).substring(0, 2).equals("B1") && occupy.get(keys).get(1).substring(0, 2).equals("R2")) {
+                        first = occupy.get(keys).get(0);
+                        second = occupy.get(keys).get(1);
+                    } else if (occupy.get(keys).get(0).substring(0, 2).equals("R2") && occupy.get(keys).get(1).substring(0, 2).equals("B1")) {
+                        first = occupy.get(keys).get(1);
+                        second = occupy.get(keys).get(0);
+                    } else {
+                        System.out.println("Error in matching between B1 and R2");
+                    }
+                    if (!isMatchBetweenB1AndR2(first.charAt(2), second.charAt(2))) {
+                        return false;
+                    }
+                }
+            }
+        }
+        return true;
+    }
+
+    /**
+     * By Shijie and Hongbo
      *
-     * @param placement  A valid piece placement string.
+     * Return an array of all solutions given a starting placement.
+     * TODO upgrade the algorithm: record the last one, use the upgraded methods
+     * @param placement A valid piece placement string.
      * @return An array of strings, each describing a solution to the game given the
      * starting point provied by placement.
      */
-    static String[] getSolutions(String placement) {
+    public static String[] getSolutions(String placement){
         // FIXME Task 10: determine all solutions to the game, given a particular starting placement
-        return null;
+        ArrayList<ArrayList> solutions = new ArrayList<>();
+        ArrayList outarray = new ArrayList();
+        String validpiece = getvalidpiece(placement);
+        String startorigin ="ABCDEFGHIJKLMNOPQRSTUVWX";
+        // if ( !isPlacementValid(placement) ) System.out.println("invalid starting piece"); //*
+        String validorigin = startorigin; // = getvalidorigin(startorigin, placement); // *
+        String orientation = "ABCDEFGHIJKL";
+
+        ArrayList<String> start = new ArrayList<>();
+        start.add(placement);
+        solutions.add(start);
+
+        ArrayList<ArrayList<HashMap<Integer,ArrayList<String>>>> lastOccupationArrayList = new ArrayList<>(); // * record last occupationArray
+        ArrayList<ArrayList<String>> lastValidOriginArray = new ArrayList<>(); // * record the last validOrigin
+        ArrayList<String> startValidOrigin = new ArrayList<>(); // *
+
+        callIsPlacementValid = 0;
+
+        int count = 0;
+
+        if (placement.length() != 36 && isPlacementValid(placement)) {
+
+            ArrayList<HashMap<Integer, ArrayList<String>>> startOccupationArray = new ArrayList<>(); // * By Hongbo Oct 1st
+            HashMap<Integer, ArrayList<String>> startTmp; // *
+            startTmp = deepCopy(occupationArray); // *
+            startOccupationArray.add(startTmp); // *
+            lastOccupationArrayList.add(startOccupationArray); // *
+
+            validorigin = getvalidorigin(startorigin,true,'A'); // * any value of the third argument is OK
+            startValidOrigin.add(validorigin); // *
+            lastValidOriginArray.add(startValidOrigin); // *
+
+            //System.out.println("startTmp: "+lastOccupationArrayList.get(0).get(0)); // *
+            while (count < validpiece.length()) { // the count-th piece
+                //System.out.println(validpiece.length()-count); // *
+                ArrayList<String> validplacement = new ArrayList<>();
+                ArrayList<HashMap<Integer,ArrayList<String>>> tmpOccuptionArray = new ArrayList<>(); // *
+                ArrayList<String> tmpValidOrigin = new ArrayList<>();
+/*
+                if ( count == 3 ) {
+                    outputFourPieces(solutions.get(0));
+                    break;
+                }
+*/
+                //System.out.println(count);
+                for (int i = 0; i < solutions.get(0).size(); i++) { // the ith solution
+                    occupationArray = deepCopy(lastOccupationArrayList.get(0).get(i)); // *
+                    //System.out.println(occupationArray); // *
+                    //validorigin = getvalidorigin(validorigin, solutions.get(0).get(i)+""); // *
+                    //System.out.println(solutions.get(0).get(i)); // *
+                    validorigin = lastValidOriginArray.get(0).get(i); // *
+                    validorigin = validOriginForThisPiece(validorigin,validpiece.charAt(count)); //**
+                    //System.out.println(validorigin); // *
+                    for (int j = 0; j < validorigin.length(); j++) { // the jth origin
+                        orientation = getValidOrientation("ABCDEFGHIJKL",validpiece.charAt(count),validorigin.charAt(j));
+                        for (int k = 0; k < orientation.length(); k++) { // the kth orientation
+                            String subplacecment = "" + solutions.get(0).get(i) + validorigin.charAt(j) + validpiece.charAt(count) + orientation.charAt(k);
+                            String thisPlacement = "" + solutions.get(0).get(i); // *
+                            String newOne = "" + validorigin.charAt(j) + validpiece.charAt(count) + orientation.charAt(k); // *
+                            //System.out.println("startTmp: "+lastOccupationArrayList.get(0).get(0)); // *
+                            //System.out.println("before: " + occupationArray); // *
+                            //System.out.println(thisPlacement+", "+newOne); // *
+                            //System.out.println("length of placcement: " + subplacecment.length() + ", checkplacement: " + subplacecment +", is valid: " + isPlacementValid(subplacecment));
+                            //if (isPlacementValid(subplacecment)) {
+                            if (isPlacementValid(thisPlacement,newOne)) { // *
+                                //System.out.println(thisPlacement+", "+newOne+", true"); // *
+                                if (subplacecment.length() == 36) {
+                                    //System.out.println("/////validplacement/////" + subplacecment);
+                                    outarray.add(subplacecment);
+                                    //System.out.println(subplacecment);
+                                } else {
+                                    validplacement.add(subplacecment);
+                                    tmpOccuptionArray.add( deepCopy(occupationArray) ); // *
+                                    //System.out.println(tmpOccuptionArray); // *
+                                    tmpValidOrigin.add(getvalidorigin(lastValidOriginArray.get(0).get(i), false,validpiece.charAt(count))); // *
+                                    //System.out.println("tmp: "+validorigin); // *
+                                }
+                            }  // else { // *
+                               // System.out.println(thisPlacement+", "+newOne+", false"); // *
+                            // } // *
+                            //System.out.println("after : " + occupationArray); // *
+                            //occupationArray = deepCopy(lastOccupationArrayList.get(0).get(i)); // * not used anymore
+                            boolean isOutofPeg = false;
+                            for (int jj = 0; jj < 3; jj++) {
+                                if (pegIndex[jj] == -1) isOutofPeg = true;
+                            }
+                            if ( ! isOutofPeg ) {
+                                restoreOccupationArray();
+                            }
+                        }
+                    }
+                }
+
+                //System.out.println(validplacement);
+                solutions.add(validplacement);
+                solutions.remove(solutions.get(0));
+                lastOccupationArrayList.add(tmpOccuptionArray); // *
+                lastOccupationArrayList.remove(lastOccupationArrayList.get(0)); // *
+                lastValidOriginArray.add(tmpValidOrigin); // *
+                lastValidOriginArray.remove(lastValidOriginArray.get(0)); // *
+                count++;
+            }
+
+            ////System.out.println("call isPlacementValid(String,String): "+ callIsPlacementValid+" times.");
+
+            //System.out.println("validorigin are: " + validorigin + ", and length is: " + validorigin.length());
+            //System.out.println(occupationArray);
+            //System.out.println("validpiece are: " + validpiece + ", count number is: " + count);
+            ////System.out.println("For this placement: " + placement + " this is outarray: " + outarray);
+            ////System.out.println("------------------------------------------------------------");
+
+            int l = outarray.size();
+/*
+            if ( l == 1 ) {
+                System.out.println("call isPlacementValid(String,String): "+ callIsPlacementValid+" times.");
+                System.out.println("For this placement: " + placement + " this is outarray: " + outarray);
+                System.out.println("------------------------------------------------------------");
+            }
+*/
+            if (l > 0) {
+                String[] output = new String[outarray.size()];
+                for (int i = 0; i < outarray.size(); i++) {
+                    output[i] = outarray.get(i) + "";
+                }
+                return output;
+            } else {
+                return null;
+            }
+
+        } else {
+            if (isPlacementValid(placement)) {
+                String[] output = {placement};
+                return output;
+            } else {
+                return null;
+            }
+        }
+        //return output;
+    }
+
+    private static void outputFourPieces(ArrayList<String> fourSolution ) {
+        try {
+            String Directory = System.getProperty("user.dir");
+            String outfilename = "JAC_FourPieces_Sols" + ".txt";
+            File outfile = new File(Directory + "/src/comp1110/ass2/SolutionDictionary", outfilename);
+
+            PrintWriter writer = new PrintWriter(outfile);
+
+            for (int i = 0; i < fourSolution.size(); i++) {
+                writer.println(fourSolution.get(i));
+            }
+            writer.close();
+        } catch (Exception e) {
+            System.out.println("open file error");
+        }
+
+    }
+
+    /**
+     * By Shijie
+     * improved by Shijie
+     * 1: check only the pegs in occupationArray, instead of checking all of 24 pegs every time.
+     * debug by Hongbo
+     * 1: occupationArray.get(origin - 'A').get(0).equals("R0null")
+     * 2: validorigin = validorigin.replace(origin + "", ""); and for (int i = 0; i < validorigin.length(); i++) are not consist
+     * improved by Hongbo
+     * 1: only update static array, pegIndex[3], if getvalidorigin is not run for the first time
+     * 2: check deadPeg ( pegIndex[3], and their neighbors)
+     * 3: check the peg facing single occupied unit R1 is valid peg or not
+     * 4: check the matching between the shape of piece and availability of neighbor pegs
+     * @param validorigin the last validorigin array, contains all the valid origin before this operation.
+     * @param isFirst if true, check all the occupationArray; if false, only check pegIndex
+     * @param piece the shape of piece is relevant in this method
+     * @return obtain all the pegs on which can place a piece
+     */
+    static String getvalidorigin(String validorigin, boolean isFirst, char piece) {
+    //static String getvalidorigin(String validorigin, String placement) {
+        /*
+        String validorigin = "ABCDEFGHIJKLMNOPQRSTUVWX";
+        if (isPlacementValid(placement)) {
+            if (!occupationArray.isEmpty()) {
+                for (int i = 0; i < 24; i++){
+                    if (occupationArray.get(i) != null){
+                        if (occupationArray.get(i).size() > 1 || occupationArray.get(i).get(0).equals("R0null")){
+                            char origin = (char) (i + 'A');
+                            validorigin = validorigin.replace(origin+"","");
+                        }
+                    }
+                }
+            }
+        }
+        */
+        //System.out.println(occupationArray); // *
+        String tmpValidOrigin = new String(validorigin); // *
+        //System.out.println("before: "+tmpValidOrigin); // *
+        if ( isFirst ) {
+            if (!occupationArray.isEmpty()) {
+                for (int i = 0; i < validorigin.length(); i++) {
+                    if (occupationArray.get(validorigin.charAt(i) - 'A') != null) {
+                        // check valid peg or not
+                        char origin = validorigin.charAt(i);
+                        if (occupationArray.get(origin - 'A').size() > 1 || occupationArray.get(origin - 'A').get(0).equals("R0null")) { // *
+                            //System.out.println(occupationArray.get(origin - 'A').get(0)); // *
+                            //validorigin = validorigin.replace(origin + "", ""); // *
+                            tmpValidOrigin = tmpValidOrigin.replace(origin + "", ""); // *
+                        }
+                        // check dead peg or not ( include check its neighbors)
+                        if ( isDeadPeg(origin-'A')) tmpValidOrigin = tmpValidOrigin.replace(origin + "", ""); // *
+                        int[] neighbors = getNeighbors(origin-'A'); // *
+                        for ( int j = 0; j < 6; j++) { // *
+                            if ( (neighbors[j] != -1) && tmpValidOrigin.contains(""+(char)(neighbors[j]+'A')) ) { // *
+                                if( isDeadPeg(neighbors[j]) ) tmpValidOrigin = tmpValidOrigin.replace((char)(neighbors[j]+'A') + "", ""); // *
+                            }
+                        }
+                        // check whether the peg facing R1 is valid or not
+                        if ( occupationArray.get(origin-'A').size() == 1 ) {
+                            if ( occupationArray.get(origin-'A').get(0).substring(0,2).equals("R1") ) {
+                                if ( ! pegFaceRing1(origin - 'A', occupationArray.get(origin - 'A').get(0).charAt(2)) ) {
+                                    tmpValidOrigin = tmpValidOrigin.replace(origin + "", "");
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        } else {
+            if (!occupationArray.isEmpty()) {  // * only check pegIndex
+                for (int i = 0; i < 3; i++) { // *
+                    int tmp = pegIndex[i];
+                    // check valid peg or not
+                    char origin = (char) (tmp + 'A'); // *
+                    if (occupationArray.get(tmp).size() > 1 || occupationArray.get(tmp).get(0).equals("R0null")) { // *
+                        tmpValidOrigin = tmpValidOrigin.replace(origin + "", ""); // *
+                    }
+                    // check dead peg or not ( include check its neighbors )
+                    int[] neighbors = getNeighbors(origin-'A'); // *
+                    //if ( isDeadPeg(tmp,neighbors) ) tmpValidOrigin = tmpValidOrigin.replace(origin + "", ""); // *
+                    if ( isDeadPeg(tmp) ) tmpValidOrigin = tmpValidOrigin.replace(origin + "", ""); // *
+                    for ( int j = 0; j < 6; j++) { // *
+                        if ( (neighbors[j] != -1) && tmpValidOrigin.contains(""+(char)(neighbors[j]+'A')) ) { // *
+                            if( isDeadPeg(neighbors[j]) ) tmpValidOrigin = tmpValidOrigin.replace((char)(neighbors[j]+'A') + "", ""); // *
+                        }
+                    }
+                    // check whether the peg facing R1 is valid or not
+                    if ( occupationArray.get(tmp).size() == 1 ) {
+                        if ( occupationArray.get(tmp).get(0).substring(0,2).equals("R1") ) {
+                            //if ( ! pegFaceRing1(tmp, occupationArray.get(tmp).get(0).charAt(2), neighbors) ) {
+                            if ( ! pegFaceRing1(tmp, occupationArray.get(tmp).get(0).charAt(2)) ) {
+                                tmpValidOrigin = tmpValidOrigin.replace(origin + "", "");
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        //System.out.println("after: "+tmpValidOrigin); // *
+        //return validorigin; // *
+        return tmpValidOrigin; // *
+    }
+
+    /**
+     * By Hongbo
+     * considering the nature of center unit of a given piece to prune by removing invalid peg,
+     * e.g. piece B,C,D,E,F,H 's center is R0, there should be nothing on that peg,
+     * piece G,K,L 's center is R1, there should be nothing or B1 on that peg
+     * piece I,J 's center is B2, there should be nothing or R2 on that peg
+     * piece A 's center is R2, there should be nothing or B2,B1 on that peg
+     * @param validorigin
+     * @param piece
+     * @return
+     */
+    static String validOriginForThisPiece(String validorigin, char piece) {
+        String tmpValidOrigin = new String(validorigin); // *
+        if (!occupationArray.isEmpty()) {
+            for (int i = 0; i < validorigin.length(); i++) {
+                if (occupationArray.get(validorigin.charAt(i) - 'A') != null) {
+                    char origin = validorigin.charAt(i);
+                    int[] neighbors = getNeighbors(origin-'A');
+                    // check the matching between piece shape and neighbor pegs
+                    if ( ! pegNeigbhorAndPieceShape(origin-'A',piece) ) tmpValidOrigin = tmpValidOrigin.replace(origin + "", "");
+                    // check the details of the peg. e.g. piece B,C,D,E,F,H 's center is R0, there should be nothing on that peg,
+                    // piece G,K,L 's center is R1, there should be nothing or B1 on that peg
+                    // piece I,J 's center is B2, there should be nothing or R2 on that peg
+                    // piece A 's center is R2, there should be nothing or B2,B1 on that peg
+                    if ( "BCDEFH".contains(piece+"") ) {
+                        tmpValidOrigin = tmpValidOrigin.replace(origin + "", "");
+                    } else if ( "GKL".contains(piece+"") ) {
+                        if ( ! occupationArray.get(origin-'A').get(0).substring(0,2).equals("B1") ) {
+                            tmpValidOrigin = tmpValidOrigin.replace(origin + "", "");
+                        }
+                    } else if ( "IJ".contains(piece+"") ) {
+                        if ( ! occupationArray.get(origin-'A').get(0).substring(0,2).equals("R2") ) {
+                            tmpValidOrigin = tmpValidOrigin.replace(origin + "", "");
+                        }
+                    } else if ( "A".contains(piece+"") ) {
+                        if ( ! occupationArray.get(origin-'A').get(0).substring(0,1).equals("B") ) {
+                            tmpValidOrigin = tmpValidOrigin.replace(origin + "", "");
+                        }
+                    }
+                }
+            }
+        }
+        return tmpValidOrigin; // *
+    }
+
+    /**
+     * By Shijie
+     * @param placement placemenet string
+     * @return the pieces which are not in the placement
+     */
+    static String getvalidpiece(String placement){
+        String validpiece = "ABCDEFGHIJKL";
+        String unvalidpiece = "";
+
+        for (int i = 1; i < placement.length(); i = i + 3){
+            unvalidpiece = unvalidpiece + placement.charAt(i);
+        }
+
+        for (int i = 0; i < unvalidpiece.length(); i++){
+            if (validpiece.contains(unvalidpiece.charAt(i)+"")){
+                validpiece = validpiece.replace(unvalidpiece.charAt(i)+"", "");
+            }
+        }
+        return validpiece;
     }
+
+    /**
+     * By Hongbo
+     * @param in input HashMap<Integer, ArrayList<String>> object to be copy deeply
+     * @return a new object
+     */
+    public static HashMap<Integer, ArrayList<String>> deepCopy(HashMap<Integer, ArrayList<String>> in) {
+        //long startTime = System.nanoTime();
+        HashMap<Integer, ArrayList<String>> out = new HashMap<>();
+        for ( Integer keys : in.keySet() ) {
+            ArrayList<String> inValue = in.get(keys);
+            ArrayList<String> tmp = new ArrayList<>();
+            for ( int i = 0; i < inValue.size(); i++ ) {
+                tmp.add(inValue.get(i));
+            }
+            out.put(keys,tmp);
+        }
+        //long endTime = System.nanoTime();
+        //totalDeepCopyTime = totalDeepCopyTime + endTime - startTime;
+        //System.out.println(totalDeepCopyTime);
+        return out;
+    }
+
+    /**
+     * By Hongbo
+     * get all the neighbors of a give peg
+     *
+     *   rt[0]  rt[1]
+     * rt[5]  peg  rt[2]
+     *   rt[4]  rt[3]
+     *
+     * @param peg which peg
+     * @return all the neighbors of peg
+     */
+    private static int[] getNeighbors(int peg) {
+        int[] neig = {-1,-1,-1,-1,-1,-1};
+        if ( peg == 0 ) {
+            neig[2] = 1;
+            neig[3] = 6;
+        } else if ( peg > 0 && peg < 5 ) {
+            neig[5] = peg - 1;
+            neig[4] = peg + 5;
+            neig[3] = peg + 6;
+            neig[2] = peg + 1;
+        } else if ( peg == 5 ) {
+            neig[5] = 4; //peg - 1;
+            neig[4] = 10; //peg + 5;
+            neig[3] = 11; //peg + 6;
+        } else if ( peg == 6 ) {
+            neig[0] = 0; //peg - 6;
+            neig[1] = 1; //peg - 5;
+            neig[2] = 7; //peg + 1;
+            neig[3] = 13; //peg + 7;
+            neig[4] = 12; //peg + 6;
+        } else if ( peg > 6 && peg < 11) {
+            neig[0] = peg - 6;
+            neig[1] = peg - 5;
+            neig[2] = peg + 1;
+            neig[3] = peg + 7;
+            neig[4] = peg + 6;
+            neig[5] = peg - 1;
+        } else if ( peg == 11) {
+            neig[0] = 5; //peg - 6;
+            neig[4] = 17; //peg + 6;
+            neig[5] = 10; //peg - 1;
+        } else if ( peg == 12) {
+            neig[1] = 6; //peg - 6;
+            neig[2] = 13; //peg + 1;
+            neig[3] = 18; //peg + 6;
+        } else if ( peg > 12 && peg < 17) {
+            neig[0] = peg - 7;
+            neig[1] = peg - 6;
+            neig[2] = peg + 1;
+            neig[3] = peg + 6;
+            neig[4] = peg + 5;
+            neig[5] = peg - 1;
+        } else if ( peg == 17) {
+            neig[0] = 10; //peg - 7;
+            neig[1] = 11; //peg - 6;
+            neig[3] = 23; //peg + 6;
+            neig[4] = 22; //peg + 5;
+            neig[5] = 16; //peg - 1;
+        } else if ( peg == 18) {
+            neig[0] = 12; //peg - 6;
+            neig[1] = 13; //peg - 5;
+            neig[2] = 19; //peg + 1;
+        } else if ( peg > 18 && peg < 23) {
+            neig[0] = peg - 6;
+            neig[1] = peg - 5;
+            neig[2] = peg + 1;
+            neig[5] = peg - 1;
+        } else if ( peg == 23 ) {
+            neig[0] = 17; //peg - 6;
+            neig[5] = 22; //peg - 1;
+        } else {
+            System.out.println("wrong peg");
+        }
+        return neig;
+    }
+
+    /**
+     * By Hongbo
+     * for any given peg, it has at most 6 neighbors.
+     * Among its neighbors pegs, if the number of pegs which can be placed with another unit is less than 2, we call the give peg dead peg.
+     * Because it can't place any piece on this given peg.
+     * @param peg the peg to be checked
+     * @return true, if dead peg; false, if not dead peg
+     */
+    private static boolean isDeadPeg(int peg) {
+        int points;
+        int[] neighbor = getNeighbors(peg);
+        points = 0;
+        for ( int i = 0; i < 6; i++) {
+            if ( neighbor[i] != -1 ) {
+                if (occupationArray.get(neighbor[i]) == null) {
+                    points = points + 1;
+                } else {
+                    if (!(occupationArray.get(neighbor[i]).size() > 1 || occupationArray.get(neighbor[i]).get(0).equals("R0null"))) {
+                        points = points + 1;
+                    }
+                }
+            }
+        }
+        return (points < 2);
+    }
+
+    /**
+     * By Hongbo
+     * for any given peg, it has at most 6 neighbors.
+     * Among its neighbors pegs, if the number of pegs which can be placed with another unit is less than 2, we call the give peg dead peg.
+     * Because it can't place any piece on this given peg.
+     * @param peg the peg to be checked
+     * @param neighbor the neighbors of peg
+     * @return true, if dead peg; false, if not dead peg
+     */
+    private static boolean isDeadPeg(int peg, int[] neighbor) {
+        int points;
+        //int[] neighbor = getNeighbors(peg);
+        points = 0;
+        for ( int i = 0; i < 6; i++) {
+            if ( neighbor[i] != -1 ) {
+                if (occupationArray.get(neighbor[i]) == null) {
+                    points = points + 1;
+                } else {
+                    if (!(occupationArray.get(neighbor[i]).size() > 1 || occupationArray.get(neighbor[i]).get(0).equals("R0null"))) {
+                        points = points + 1;
+                    }
+                }
+            }
+        }
+        return (points < 2);
+    }
+
+    /**
+     * By Hongbo
+     * @param peg on which peg the Ring1 is
+     * @param ori the ori of Ring1
+     * @return true, if the peg facing opening of R1 is a valid peg; false, if not
+     */
+    private static boolean pegFaceRing1(int peg, char ori) {
+        int[] neighbors = getNeighbors(peg);
+        int facedPeg;
+        if ( ori == 'A') {
+            facedPeg = neighbors[5];
+        } else {
+            facedPeg = neighbors[ori-'B'];
+        }
+        if ( facedPeg == -1 ) return false;
+        if ( occupationArray.get(facedPeg) == null ) return true;
+        if ( occupationArray.get(facedPeg).size() > 1 || occupationArray.get(facedPeg).get(0).equals("R0null") ) return false;
+        return true;
+    }
+
+    /**
+     * By Hongbo
+     * @param peg on which peg the Ring1 is
+     * @param ori the ori of Ring1
+     * @param neighbors the neighbors of peg
+     * @return true, if the peg facing opening of R1 is a valid peg; false, if not
+     */
+    private static boolean pegFaceRing1(int peg, char ori, int[] neighbors) {
+        //int[] neighbors = getNeighbors(peg);
+        int facedPeg;
+        if ( ori == 'A') {
+            facedPeg = neighbors[5];
+        } else {
+            facedPeg = neighbors[ori-'B'];
+        }
+        if ( facedPeg == -1 ) return false;
+        if ( occupationArray.get(facedPeg) == null ) return true;
+        if ( occupationArray.get(facedPeg).size() > 1 || occupationArray.get(facedPeg).get(0).equals("R0null") ) return false;
+        return true;
+    }
+
+    /**
+     * determine whether a given peg is valid or not by checking whether
+     * the shape of piece and the valid pegs in the neighbors of a given peg matches or not.
+     * @param peg peg index
+     * @param piece the shape of the piece is relevant
+     * @return true, if match; false, if not match
+     */
+    private static boolean pegNeigbhorAndPieceShape(int peg, char piece) {
+        int shape = -1; // 1 for line shape; 2 for obtuse shape; 3 for acute shape
+        if ( "ABC".contains(piece+"") ) {
+            shape = 1;
+        } else if ( "DEFGH".contains(piece+"") ) {
+            shape = 2;
+        } else if ( "IJKL".contains(piece+"") ) {
+            shape = 3;
+        }
+        int[] neighbor = getNeighbors(peg);
+        boolean[] neighborValid = {false,false,false,false,false,false};
+        for ( int i = 0; i < 6; i++) {
+            if ( neighbor[i] != -1 ) {
+                if (occupationArray.get(neighbor[i]) == null) {
+                    neighborValid[i] = true;
+                } else {
+                    if (!(occupationArray.get(neighbor[i]).size() > 1 || occupationArray.get(neighbor[i]).get(0).equals("R0null"))) {
+                        neighborValid[i] = true;
+                    }
+                }
+            }
+        }
+        boolean condition1, condition2, condition3, condition4, condition5, condition6;
+        if ( shape == 1) {
+            condition1 = neighborValid[0] && neighborValid[3];
+            condition2 = neighborValid[1] && neighborValid[4];
+            condition3 = neighborValid[2] && neighborValid[5];
+            if ( condition1 || condition2 || condition3 ) return true;
+        } else if ( shape == 2 ) {
+            condition1 = neighborValid[0] && neighborValid[2];
+            condition2 = neighborValid[1] && neighborValid[3];
+            condition3 = neighborValid[2] && neighborValid[4];
+            condition4 = neighborValid[3] && neighborValid[5];
+            condition5 = neighborValid[4] && neighborValid[0];
+            condition6 = neighborValid[5] && neighborValid[1];
+            if ( condition1 || condition2 || condition3 || condition4 || condition5 || condition6 ) return true;
+        } else if ( shape == 3 ) {
+            condition1 = neighborValid[0] && neighborValid[1];
+            condition2 = neighborValid[1] && neighborValid[2];
+            condition3 = neighborValid[2] && neighborValid[3];
+            condition4 = neighborValid[3] && neighborValid[4];
+            condition5 = neighborValid[4] && neighborValid[5];
+            condition6 = neighborValid[5] && neighborValid[0];
+            if ( condition1 || condition2 || condition3 || condition4 || condition5 || condition6 ) return true;
+        }
+        return false;
+    }
+
+    /**
+     * determine whether a given peg is valid or not by checking whether
+     * the shape of piece and the valid pegs in the neighbors of a given peg matches or not.
+     * @param peg peg index
+     * @param piece the shape of the piece is relevant
+     * @param neighbor the neighbors of the peg
+     * @return true, if match; false, if not match
+     */
+    private static boolean pegNeigbhorAndPieceShape(int peg, char piece, int[] neighbor) {
+        int shape = -1; // 1 for line shape; 2 for obtuse shape; 3 for acute shape
+        if ( "ABC".contains(piece+"") ) {
+            shape = 1;
+        } else if ( "DEFGH".contains(piece+"") ) {
+            shape = 2;
+        } else if ( "IJKL".contains(piece+"") ) {
+            shape = 3;
+        }
+        //int[] neighbor = getNeighbors(peg);
+        boolean[] neighborValid = {false,false,false,false,false,false};
+        for ( int i = 0; i < 6; i++) {
+            if ( neighbor[i] != -1 ) {
+                if (occupationArray.get(neighbor[i]) == null) {
+                    neighborValid[i] = true;
+                } else {
+                    if (!(occupationArray.get(neighbor[i]).size() > 1 || occupationArray.get(neighbor[i]).get(0).equals("R0null"))) {
+                        neighborValid[i] = true;
+                    }
+                }
+            }
+        }
+        boolean condition1, condition2, condition3, condition4, condition5, condition6;
+        if ( shape == 1) {
+            condition1 = neighborValid[0] && neighborValid[3];
+            condition2 = neighborValid[1] && neighborValid[4];
+            condition3 = neighborValid[2] && neighborValid[5];
+            if ( condition1 || condition2 || condition3 ) return true;
+        } else if ( shape == 2 ) {
+            condition1 = neighborValid[0] && neighborValid[2];
+            condition2 = neighborValid[1] && neighborValid[3];
+            condition3 = neighborValid[2] && neighborValid[4];
+            condition4 = neighborValid[3] && neighborValid[5];
+            condition5 = neighborValid[4] && neighborValid[0];
+            condition6 = neighborValid[5] && neighborValid[1];
+            if ( condition1 || condition2 || condition3 || condition4 || condition5 || condition6 ) return true;
+        } else if ( shape == 3 ) {
+            condition1 = neighborValid[0] && neighborValid[1];
+            condition2 = neighborValid[1] && neighborValid[2];
+            condition3 = neighborValid[2] && neighborValid[3];
+            condition4 = neighborValid[3] && neighborValid[4];
+            condition5 = neighborValid[4] && neighborValid[5];
+            condition6 = neighborValid[5] && neighborValid[0];
+            if ( condition1 || condition2 || condition3 || condition4 || condition5 || condition6 ) return true;
+        }
+        return false;
+    }
+
+    /**
+     * By Hongbo
+     * use the shape of piece and availability of neighbors to constraint the possible orientation of piece
+     * @param startOrientation "A..L" length = 12
+     * @param piece the shape of piece is relevant here
+     * @param peg which peg, the neighbors are relevant here
+     * @return
+     */
+    public static String getValidOrientation(String startOrientation, char piece, char peg) {
+        String rt = startOrientation;
+        int shape = -1; // 1 for line shape; 2 for obtuse shape; 3 for acute shape
+        if ( "ABC".contains(piece+"") ) {
+            shape = 1;
+        } else if ( "DEFGH".contains(piece+"") ) {
+            shape = 2;
+        } else if ( "IJKL".contains(piece+"") ) {
+            shape = 3;
+        }
+
+        if ( piece == 'A' ) rt = rt.replace("G","").replace("H","").replace("I","").replace("J","").replace("K","").replace("L","");
+
+        int[] neighbor = getNeighbors(peg-'A');
+        boolean[] neighborValid = {false,false,false,false,false,false};
+        for ( int i = 0; i < 6; i++) {
+            if ( neighbor[i] != -1 ) {
+                if (occupationArray.get(neighbor[i]) == null) {
+                    neighborValid[i] = true;
+                } else {
+                    if (!(occupationArray.get(neighbor[i]).size() > 1 || occupationArray.get(neighbor[i]).get(0).equals("R0null"))) {
+                        neighborValid[i] = true;
+                    }
+                }
+            }
+        }
+        //for ( int ii = 0; ii < 6; ii++) {
+          //  System.out.print(neighborValid[ii]+" ");
+        //}
+        //System.out.print("\n");
+        boolean condition1, condition2, condition3, condition4, condition5, condition6;
+        if ( shape == 1) {
+            condition1 = neighborValid[0] && neighborValid[3];
+            condition2 = neighborValid[1] && neighborValid[4];
+            condition3 = neighborValid[2] && neighborValid[5];
+            if ( ! condition1 ) rt = rt.replace("B","").replace("E","").replace("H","").replace("K","");
+            if ( ! condition2 ) rt = rt.replace("C","").replace("F","").replace("I","").replace("L","");
+            if ( ! condition3 ) rt = rt.replace("A","").replace("D","").replace("G","").replace("J","");
+        } else if ( shape == 2 ) {
+            condition1 = neighborValid[0] && neighborValid[2];
+            condition2 = neighborValid[1] && neighborValid[3];
+            condition3 = neighborValid[2] && neighborValid[4];
+            condition4 = neighborValid[3] && neighborValid[5];
+            condition5 = neighborValid[4] && neighborValid[0];
+            condition6 = neighborValid[5] && neighborValid[1];
+            if ( ! condition1 ) rt = rt.replace("B","").replace("J","");
+            if ( ! condition2 ) rt = rt.replace("C","").replace("K","");
+            if ( ! condition3 ) rt = rt.replace("D","").replace("L","");
+            if ( ! condition4 ) rt = rt.replace("E","").replace("G","");
+            if ( ! condition5 ) rt = rt.replace("F","").replace("H","");
+            if ( ! condition6 ) rt = rt.replace("A","").replace("I","");
+        } else if ( shape == 3 ) {
+            condition1 = neighborValid[0] && neighborValid[1];
+            condition2 = neighborValid[1] && neighborValid[2];
+            condition3 = neighborValid[2] && neighborValid[3];
+            condition4 = neighborValid[3] && neighborValid[4];
+            condition5 = neighborValid[4] && neighborValid[5];
+            condition6 = neighborValid[5] && neighborValid[0];
+            if ( ! condition1 ) rt = rt.replace("B","").replace("I","");
+            if ( ! condition2 ) rt = rt.replace("C","").replace("J","");
+            if ( ! condition3 ) rt = rt.replace("D","").replace("K","");
+            if ( ! condition4 ) rt = rt.replace("E","").replace("L","");
+            if ( ! condition5 ) rt = rt.replace("F","").replace("G","");
+            if ( ! condition6 ) rt = rt.replace("A","").replace("H","");
+        }
+        return rt;
+    }
+
+    /**
+     * By Hongbo
+     * avoid to deepCope a Hashmap in every iterations
+     */
+    private static void restoreOccupationArray() {
+        int key;
+        for (int j = 0; j < 3; j++) {
+            key = pegIndex[j];
+            int len = occupationArray.get(key).size();
+            if ( len == 1) {
+                occupationArray.remove(key);
+            } else {
+                occupationArray.get(key).remove(len - 1);
+            }
+        }
+    }
+
+    // for debug
+    public static void main(String[] args) {
+        //isPlacementValid("BAAHBATCJRDKWEBEFDNGLPHEDIFMJJQKIKLJ");
+        //isPlacementValid("KAFUBAICCPDALEFEFEQGHSHBNIB");
+        //System.out.println(isPlacementValid("KAFUBAICCPDALEFEFEQGHSHBNIB"));
+        //isPlacementValid("JABHBCBCGGDFIEKVFAFGGSHBXIAJJJUKHKLK");
+        //System.out.println(isPlacementValid("JABHBCBCGGDFIEKVFAFGGSHBXIAJJJUKHKLK"));
+        //System.out.println(isPlacementValid("KAFUBAICCPDALEFEFEQGHSHBNIB","CJF"));
+        //System.out.println(isPlacementValid("KAFCBGUCAGDFLEFPFBBGESHB","OIA"));
+        //isPlacementValid("JABJJJ");
+        //isPlacementValid("KAFUBAICC");
+        //isPlacementValid("KAFUBA");
+        //isPlacementValid("KAF");
+        //isPlacementValid("KAFCBGUCAGDFLEFPFBBGESHBWIJKJAHKLJLH")
+        //isPlacementValid("RDK");
+        //isPlacementValid("RDKWEB");
+        //isPlacementValid("KAFEFE");
+        //getSolutions("JAC");
+    }
+
 }
Only in comp1110-ass2/src/comp1110/ass2: Orientation.class
Only in comp1110-ass2/src/comp1110/ass2: Orientation.java
Only in comp1110-ass2/src/comp1110/ass2: Piece.class
Only in comp1110-ass2/src/comp1110/ass2: Piece.java
Only in comp1110-ass2/src/comp1110/ass2: PiecePlacement.class
Only in comp1110-ass2/src/comp1110/ass2: PiecePlacement.java
Only in comp1110-ass2/src/comp1110/ass2: SolutionDictionary
Only in comp1110-ass2/src/comp1110/ass2: UandO.class
Only in comp1110-ass2/src/comp1110/ass2: UandO.java
Only in comp1110-ass2/src/comp1110/ass2: Unit.class
Only in comp1110-ass2/src/comp1110/ass2: Unit.java
Only in comp1110-ass2/src: gittest
Only in comp1110-ass2/src: utils
Only in comp1110-ass2/tests/comp1110/ass2: FixTest.java
Only in comp1110-ass2/tests/comp1110/ass2: toStringTest.java
Only in comp1110-ass2/tests/comp1110/ass2: TranslateOrientationTest.java
Only in comp1110-ass2: uml.pdf
Only in comp1110-ass2: uml.png
```
## Test log
```
--javac output--
Note: comp1110-ass2/src/comp1110/ass2/LinkGame.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
----
java -cp comp1110-ass2/src:/home/jolan/comp1110-tutors/bin/../ass2/ass2-1110-tests.jar:/home/jolan/comp1110-tutors/bin/../ass2/hamcrest-core-1.3.jar:/home/jolan/comp1110-tutors/bin/../ass2/junit-4.12.jar org.junit.runner.JUnitCore comp1110.ass2.PiecePlacementWellFormedTest
---
JUnit version 4.12
.....
Time: 0.015

OK (5 tests)

java -cp comp1110-ass2/src:/home/jolan/comp1110-tutors/bin/../ass2/ass2-1110-tests.jar:/home/jolan/comp1110-tutors/bin/../ass2/hamcrest-core-1.3.jar:/home/jolan/comp1110-tutors/bin/../ass2/junit-4.12.jar org.junit.runner.JUnitCore comp1110.ass2.PlacementWellFormedTest
---
JUnit version 4.12
.....
Time: 0.024

OK (5 tests)

java -cp comp1110-ass2/src:/home/jolan/comp1110-tutors/bin/../ass2/ass2-1110-tests.jar:/home/jolan/comp1110-tutors/bin/../ass2/hamcrest-core-1.3.jar:/home/jolan/comp1110-tutors/bin/../ass2/junit-4.12.jar org.junit.runner.JUnitCore comp1110.ass2.PegsForPiecePlacementTest
---
JUnit version 4.12
....
Time: 0.02

OK (4 tests)

java -cp comp1110-ass2/src:/home/jolan/comp1110-tutors/bin/../ass2/ass2-1110-tests.jar:/home/jolan/comp1110-tutors/bin/../ass2/hamcrest-core-1.3.jar:/home/jolan/comp1110-tutors/bin/../ass2/junit-4.12.jar org.junit.runner.JUnitCore comp1110.ass2.PlacementValidTest
---
JUnit version 4.12
.....
Time: 0.041

OK (5 tests)

java -cp comp1110-ass2/src:/home/jolan/comp1110-tutors/bin/../ass2/ass2-1110-tests.jar:/home/jolan/comp1110-tutors/bin/../ass2/hamcrest-core-1.3.jar:/home/jolan/comp1110-tutors/bin/../ass2/junit-4.12.jar org.junit.runner.JUnitCore comp1110.ass2.SolutionsTest
---
JUnit version 4.12
..
Time: 2.798

OK (2 tests)

```
